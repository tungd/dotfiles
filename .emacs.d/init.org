#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I
install them automatically with =use-package.el= instead of using =package.el=
directly.

I'm also trying out some of the start-up optimization tips from Doom.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package))

  (setq package-quickstart t)

  (setq-default bidi-display-reordering nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  (eval-when-compile
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)

  (use-package diminish :ensure t)
#+END_SRC

Use a dedicate custom file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+END_SRC

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+END_SRC


* Defaults

Personal information that some package use:

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Tung Dao"
        user-mail-address "me@tungdao.com"
        default-input-method 'vietnamese-telex)
  (defvar personal-keybindings nil)
#+END_SRC

Less verbose choice:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :hook (after-init . exec-path-from-shell-initialize)
    :config
    (exec-path-from-shell-copy-envs '("LANG")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-command-modifier 'meta
        ns-option-modifier 'super
        trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :hook (after-init . smex-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
#+END_SRC

** Server

#+BEGIN_SRC emacs-lisp
  (defun td/ensure-server-running ()
    (require 'server)
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook #'td/ensure-server-running)
#+END_SRC


* Navigation

** File position

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :hook (after-init . save-place-mode))
#+END_SRC

** Projects

I use =projectile= to switch between projects and between files in
the same project. When possible I will use the functions provided
by Emacs, however the project facilities built-in in recent version
of Emacs but it is still bare bone.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :hook (after-init . projectile-mode)
    :bind (("M-C-'" . projectile-find-file)
           (:map projectile-mode-map ("C-c p" . projectile-command-map)))
    :config
    (setq projectile-globally-ignored-file-suffixes
          '("jpg" "png" "svg" "psd" "sketch" "afdesign"
            "pdf" "doc" "docx" "xls" "xlsx"
            "ttf" "otf" "woff"
            "rar" "zip" "min.js" "min.css" "map")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/kill-project-buffers ()
    (interactive)
    (let ((project (project-current)))
      (cl-loop for buffer in (buffer-list)
               if (with-current-buffer buffer
                    (equal project (project-current)))
               do (kill-buffer buffer))))

  (use-package project
    :bind (("C-M-'" . project-find-file)
           ("C-c p s" . ag-project)
           ("C-c p k" . td/kill-project-buffers)))
#+END_SRC

** Symbols

For jumping to defined symbols (functions, classes, .etc), I use
=dump-jump=. Mode specific support for this feature is at higher
priority, when they fail =dump-jump= will be the fallback.

The key bindings are:

| Binding | Command                | Description    |
|---------+------------------------+----------------|
| =C-M-g= | =dump-jump-go=         | Jump to symbol |
| =C-M-p= | =dump-jump-back=       | Back           |
| =C-M-q= | =dump-jump-quick-look= | Quick look     |

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :hook (prog-mode . dumb-jump-mode))
#+END_SRC

** Ivy

Ivy is a nice completion package, however the main reason I use it over =ido=
is that I can make its popup appear at the top of the window.

#+BEGIN_SRC emacs-lisp
  (ido-mode -1)

  (add-to-list 'completion-styles 'flex)

  (use-package ivy
    :diminish ivy-mode
    :hook (after-init . ivy-mode)
    :bind (("C-M-o" . ivy-switch-buffer))
    :config
    (setq ivy-use-virtual-buffers t
          ivy-count-format ""
          ivy-height 16))

  (use-package ivy-posframe
    :diminish ivy-posframe-mode
    :hook (after-init . ivy-posframe-mode)
    :config
    (setq ivy-posframe-style 'frame-center
          ivy-posframe-parameters
          '((internal-border-width . 8)
            (internal-border-color . "#fff")
            (background-color . "#000"))))

  (use-package counsel
    :ensure t
    :bind (([remap find-file] . counsel-find-file)
           ([remap ido-find-file] . counsel-find-file)
           ([remap execute-extended-command] . counsel-M-x)
           ;; ("C-M-'" . counsel-git)
           ("M-\"" . counsel-git-grep)
           ("M-m" . counsel-M-x)
           ("C-c i" . counsel-imenu)))

  (use-package imenu
    :hook (imenu-after-jump . recenter-top-bottom))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ivy-posframe
    :ensure t
    :defer t
    :config
    (eval-and-compile
      (defun ivy-posframe-display-at-frame-top-left (str)
        (ivy-posframe--display str #'posframe-poshandler-window-top-left-corner))
      (ivy-posframe-setup)
      (setq ivy-display-function #'ivy-posframe-display-at-frame-top-left))
    :hook (ivy-mode . (lambda () (require 'ivy-posframe))))
#+END_SRC

Use =historian.el= to sort ivy completion based on frequency - similar to smex.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-historian
    :ensure t
    :defer t
    :hook (ivy-mode . ivy-historian-mode))
#+END_SRC


* Window Management

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package shackle
    :ensure t
    :hook (after-init . shackle-mode)
    :config
    (setq shackle-default-alignment 'below
          shackle-default-rule
          '((compilation-mode :align 'below))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package window-numbering
    :ensure t
    :hook (after-init . window-numbering-mode)
    :config
    (eval-and-compile
      (defun td/window-numbering-get-number-string (number-string)
        (format "[%s] " number-string))
      (advice-add 'window-numbering-get-number-string
                  :filter-return #'td/window-numbering-get-number-string)))
#+END_SRC


* General Editing

#+BEGIN_SRC emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
    :ensure t
    :bind ([remap comment-dwim] . comment-dwim-2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer))
#+END_SRC

Basic settings:

#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width 2
   indent-tabs-mode nil
   require-final-newline t
   reb-re-syntax 'string)
#+END_SRC

Editing utilities:

#+BEGIN_SRC emacs-lisp
  (defun td/visit-eshell-buffer ()
    (interactive)
    (crux-start-or-switch-to #'eshell "*eshell*"))

  (use-package crux
    :ensure t
    :hook (after-init . crux-reopen-as-root-mode)
    :bind (("C-M-]" . crux-switch-to-previous-buffer)
           ("M-J" . crux-top-join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c C-o" . crux-open-with)
           ;("C-c t" . crux-visit-term-buffer)
           ("C-c s" . td/visit-eshell-buffer)
           ([remap kill-line] . crux-smart-kill-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save))

  (bind-key "C-c C-k" #'kill-this-buffer)
  (bind-key [remap delete-horizontal-space] #'cycle-spacing)
#+END_SRC

Automatically apply external changes: This is debatable, from my own
experience it is helpful.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :diminish auto-revert-mode
    :hook (after-init . global-auto-revert-mode)
    :config
    (setq auto-revert-avoid-polling t))
#+END_SRC

Automatically save buffers when focus out:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun td/save-all-buffers ()
    (interactive)
    (save-some-buffers t))

  (add-hook 'focus-out-hook 'td/save-all-buffers)
#+END_SRC

Create directory for the file if not exists:

#+BEGIN_SRC emacs-lisp
  (defun td/make-new-directories ()
    (let ((dir (file-name-directory buffer-file-name)))
      (when (and buffer-file-name (not (file-exists-p dir)))
        (make-directory dir t))))

  (add-to-list 'find-file-not-found-functions #'td/make-new-directories)
#+END_SRC

Make the file executable if starting with "shebang":

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

I was a pretty die-hard Vim fanboy, let's bring back the memory.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil
    :ensure t
    :defer t
    :hook (after-init . evil-mode)
    :bind (:map evil-normal-state-map ("M-." . xref-find-definitions))
    :config
    (setq evil-cross-lines t
          evil-ex-substitute-global t))

  (use-package evil-surround
    :ensure t
    :defer t
    :after evil
    :hook (evil-mode . global-evil-surround-mode))

  (use-package evil-visualstar
    :ensure t
    :defer t
    :after evil
    :hook (evil-mode . global-evil-visualstar-mode))
#+END_SRC

** Search and replace

Anzu command names are confusing, at-cursor means initial string, while thing
means boundary.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :diminish anzu-mode
    :hook (after-init . global-anzu-mode)
    :bind (("M-r" . anzu-query-replace-regexp)
           ("C-M-r" . anzu-replace-at-cursor-thing)))
#+END_SRC

Also define "buffer-at-point" so that we can do query-replace in the whole
buffer without having to jump to the beginning.

#+BEGIN_SRC emacs-lisp
  (use-package thingatpt
    :after (anzu)
    :config
    (eval-and-compile
      (defun td/bounds-of-buffer-at-point ()
        (cons (point-min) (point-max)))

      (put 'buffer 'bounds-of-thing-at-point 'td/bounds-of-buffer-at-point)
      (put 'buffer 'beginning-op 'beginning-of-buffer)
      (put 'buffer 'end-op 'end-of-buffer)))
#+END_SRC

I also use ISearch for navigation. In such cases I want to put the cursor at
the beginning of the match, not the end.

#+BEGIN_SRC emacs-lisp
  (setq lazy-highlight-initial-delay 0
        ;isearch-lazy-count t
        isearch-lazy-highlight-buffer t)

  (defun td/isearch-exit-goto-match-beginning ()
    (interactive)
    (when (and isearch-forward isearch-other-end)
      (goto-char isearch-other-end)))

  (add-hook 'isearch-mode-end-hook #'td/isearch-exit-goto-match-beginning)
  (advice-add 'isearch-exit :after #'td/isearch-exit-goto-match-beginning)

  (defun td/isearch-delete-dwim ()
    "Delete the failed portion or last char if succesful search."
    (interactive)
    (if (= 0 (length isearch-string))
        (ding)
      (setq isearch-string
            (substring
             isearch-string 0 (or (isearch-fail-pos) (1- (length isearch-string))))
            isearch-message
            (mapconcat 'isearch-text-char-description isearch-string ""))
      (funcall (or isearch-message-function #'isearch-message) nil t)
      (if isearch-other-end (goto-char isearch-other-end))
      (isearch-search)
      (isearch-push-state)
      (isearch-update)))

  (bind-key [remap isearch-delete-char] #'td/isearch-delete-dwim isearch-mode-map)
#+END_SRC

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+BEGIN_SRC emacs-lisp
  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'prog-mode-hook #'turn-on-auto-fill)
#+END_SRC

Sometimes long lines are inevitable though, as I do have to manually edit
exported SVG and minified JS :(. In those cases prevent them from making Emacs
slow:

#+BEGIN_SRC emacs-lisp
  (global-so-long-mode t)
#+END_SRC

** Whitespace

Cleanup whitespaces automatically on save.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup))
#+END_SRC

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
use =smart-parens= to manage them. However the command name use words from an
arcane language :(, so I put together a table of human-readable description of
the commands. All key bindings are started with =M-s=.

| Bindings  | Command                | Description                                         |
|-----------+------------------------+-----------------------------------------------------|
| =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
| =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
| =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
| =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

NOTE: This package is huge, I'm still learning it.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :hook ((prog-mode . smartparens-mode)
           (prog-mode . show-smartparens-mode))
    :bind (("M-s DEL" . sp-splice-sexp)
           ("M-S" . sp-rewrap-sexp)
           ("M-s <right>" . sp-slurp-hybrid-sexp)
           ("C-S-f" . sp-slurp-hybrid-sexp)
           ("M-s <left>" . sp-forward-barf-sexp)
           ("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("M-K" . sp-kill-sexp)
           ("M-]" . sp-select-next-thing))
    :config
    (setq sp-show-pair-delay 0)
    (sp-pair "{" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("M--" . er/expand-region))

  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)
#+END_SRC

** Undo

By default Emacs doesn't even have redo!

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :hook (after-init . global-undo-tree-mode)
    :config
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist
          `((".*" . ,(concat user-emacs-directory "undos")))))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :hook (after-init . yas-global-mode)
    :init
    (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
    :config
    (progn
      (setq yas-prompt-functions
            '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
            yas-verbosity 1)

      ;; I'm an old Emacs hacker. I like the abbrev-way and bind yas-expand to
      ;; SPC.
      (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

      (unbind-key "TAB" yas-minor-mode-map)
      (unbind-key "<tab>" yas-minor-mode-map)))
#+END_SRC

** Alignment

#+BEGIN_SRC emacs-lisp
  (use-package align
    :defer t
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode web-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(ruby-hash
                   (modes . '(ruby-mode))
                   (regexp . "\\(\\s-*\\)=>")
                   (spacing . 1)))
    )
#+END_SRC

** Recent files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :defer t
    :config
    (setq recentf-max-saved-items 128
          recentf-exclude
          '("/auto-install/" ".recentf" "/repos/" "/elpa/"
            "\\.mime-example" "\\.ido.last" "COMMIT_EDITMSG"
            ".gz" "~$" "/tmp/" "/ssh:" "/sudo:" "/scp:")))
#+END_SRC

** Diff

#+BEGIN_SRC emacs-lisp
  (setq-default ediff-split-window-function #'split-window-horizontally)
#+END_SRC


* Shell and remote

** EShell

#+BEGIN_SRC emacs-lisp
  (defun td/with-face (str &rest properties)
    (propertize str 'face properties))

  (use-package eshell
    :defer t
    :config
    (eval-and-compile
      (defun td/eshell-pwd ()
        (replace-regexp-in-string
         (regexp-quote (expand-file-name "~"))
         "~"
         (eshell/pwd)))

      (defun td/eshell-prompt ()
        (format
         "\n%s@%s in %s\n%s "
         (td/with-face user-login-name :foreground "#dc322f")
         (td/with-face (or (getenv "HOST") (system-name)) :foreground "#b58900")
         (td/with-face (td/eshell-pwd) :foreground "#859900")
         (if (= (user-uid) 0) (td/with-face "#" :foreground "red") "$")))

      (defalias 'eshell/e 'find-file-other-window)

      (defun eshell/open (args)
        (interactive)
        (shell-command
         (concat (cl-case system-type
                   ((darwin) "open")
                   ((windows-nt) "start")
                   (t "xdg-open"))
                 (format " %s" args))))

      (use-package em-prompt
        :defer t
        :config
        (setq eshell-prompt-function #'td/eshell-prompt
              eshell-prompt-regexp "^[^#$\\n]*[#$] "
              eshell-highlight-prompt nil))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t
    :init
    (defun eshell/ag (args) (ag args (eshell/pwd))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :ensure t
    :hook ((term-exec . with-editor-export-editor)
           (shell-mode . with-editor-export-editor)
           (eshell-mode . with-editor-export-editor)))
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (eval-and-compile
      (setq password-cache-expiry nil
            tramp-debug-buffer t
            tramp-default-method "ssh"
            tramp-verbose 2)

      (add-to-list 'auth-sources "~/.emacs.d/authinfo.gpg")
      (setq ange-ftp-netrc-filename "~/.emacs.d/authinfo.gpg")))
#+END_SRC


* Programming

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :ensure t
    :hook ((js-mode . eglot-ensure)
           (typescript-mode . eglot-ensure)
           (python-mode . eglot-ensure)
           (haskell-mode . eglot-ensure)
           (java-mode . eglot-ensure)
           (rust-mode . eglot-ensure)
           (tuareg-mode . eglot-ensure))
    :bind (:map eglot-mode-map ("C-c h" . eglot-help-at-point))
    :config
    (setq eglot-sync-connect nil
          eglot-ignored-server-capabilites
          '(:documentHighlightProvider :hoverProvider))
    (add-to-list 'eglot-server-programs
                 '(tuareg-mode . ("opam" "exec" "--" "ocamlmerlin-lsp" "--stdio"))))
#+END_SRC

** Auto completion

I use auto completion sparingly. Mostly because many of the programing
language support package use =company= for some of their functionalities. To
be fair, I'd like these mode to support Emacs's standard
=completion-at-point-functions= interface.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish company-mode
    :bind (("M-/" . company-complete-common-or-cycle)
           ("C-x C-p" . company-files)
           :map company-active-map
           ("<tab>" . company-complete-common-or-cycle)
           ("C-n" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort))
    :hook (after-init . global-company-mode)
    :config
    (setq company-minimum-prefix-length 2
          company-require-match nil
          company-idle-delay nil
          company-tooltip-align-annotations t
          company-echo-delay 0
          company-frontends
          '(company-pseudo-tooltip-unless-just-one-frontend
            company-echo-metadata-frontend)
          company-backends
          '((company-capf :with company-dabbrev-code company-yasnippet))))

  (use-package company-buffer-line
    :commands (company-same-mode-buffer-lines)
    :bind ("C-x C-l" . company-same-mode-buffer-lines))

  (use-package company-statistics
    :ensure t
    :defer t
    :hook (global-company-mode . company-statistics-mode))
#+END_SRC

** Error checking

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck
    :ensure t
    :commands (flycheck-mode)
    :functions (flycheck-add-mode flycheck-add-next-checker)
    :hook (prog-mode . flycheck-mode)
    :config
    (eval-and-compile
      (setq-default flycheck-disabled-checkers '(scss emacs-lisp-checkdoc)
                    flycheck-hlintrc ".hlint.yaml")))
#+END_SRC

Flymake have a rewrite in Emacs 26.1. I'm giving it a try now

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error))
    :config
    (defun flymake-proc-create-temp-in-tmp (file-name)
      (concat temporary-file-directory file-name))

    (advice-add
     'flymake-proc-create-temp-inplace
     :filter-return #'flymake-proc-create-temp-in-tmp))
#+END_SRC

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-c p v" . magit-status)
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+END_SRC

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+BEGIN_SRC emacs-lisp
  (setq-default compilation-scroll-output 'first-error)
  (bind-key "C-c m" #'recompile)

  (defun td/compilation-hide-window-on-finish (buffer string)
    (if (and (string-match "compilation" (buffer-name buffer))
             (string-match "finished" string)
             (not (with-current-buffer buffer
                    (search-forward "warning" nil t)))
             (not (with-current-buffer buffer
                    (search-forward "Error" nil t))))
        (run-with-timer 1 nil #'delete-window (get-buffer-window buffer))))

  ;; (add-hook 'compilation-finish-functions #'td/compilation-hide-window-on-finish)
#+END_SRC

** Code folding

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hideshowvis
    :ensure t
    :hook (hs-minor-mode . hideshowvis-enable))
#+END_SRC

** Web Development

Not programming per-se. I use =web-mode= for all my templating-related
editing, including PHP, since I rarely write PHP anymore.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html" . web-mode)
           ;; ("\\.jsx" . web-mode)
           ("\\.tsx" . web-mode)
           ("\\.tpl" . web-mode)
           ("\\.erb" . web-mode)
           ("\\.tag" . web-mode)
           ("\\.php" . web-mode)
           ("\\.hbs" . web-mode)
           ("\\.mustache" . web-mode))
    :hook (web-mode . turn-off-auto-fill)
    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-script-padding 2
          web-mode-style-padding 2))
#+END_SRC

Also, I can't live without Emmet.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :diminish emmet-mode
    :hook ((sgml-mode . emmet-mode)
           (css-mode . emmet-mode)
           (web-mode . emmet-mode)
           (js-jsx-mode . emmet-mode))
    :config
    (setq emmet-indentation 2
          emmet-preview-default nil
          emmet-insert-flash-time 0.1)

    (defun td/emmet-jsx-mode ()
      (interactive)
      (when (string-suffix-p "sx" (buffer-file-name))
        (setq-local emmet-expand-jsx-className? t)))

    (add-hook 'emmet-mode-hook #'td/emmet-jsx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+END_SRC

** OCaml

#+BEGIN_SRC emacs-lisp
  (use-package tuareg
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package utop
    :ensure t
    :diminish utop-minor-mode
    :commands (utop)
    :hook (tuareg-mode . utop-minor-mode)
    :config (setq utop-command "opam config exec -- utop -emacs"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dune :ensure t)
#+END_SRC

** PHP

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package php-mode
    :ensure t
    :mode (("\\.php" . php-mode))
    :config
    (setq php-mode-coding-style 'drupal))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css\\'"
    :config
    (setq css-indent-offset 2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook (css-mode . rainbow-mode))
#+END_SRC

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try

#+BEGIN_SRC emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . js-mode))
    :config
    (setq js-indent-level 2
          js-indent-first-init 'dynamic
          js-switch-indent-offset 2
          js-enabled-frameworks '(javascript)))

  (use-package add-node-modules-path
    :ensure t
    :defer t
    :hook (js-mode . add-node-modules-path))
#+END_SRC

Well, I'm also on the TypeScript train lately, mostly because of the super
awesome StencilJS project.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package typescript-mode
    :ensure t
    :mode "\\.ts"
    :config
    (eval-and-compile
      (setq typescript-indent-level 2)
      (defun td/enable-tslint-web-mode ()
        (interactive)
        (flycheck-add-mode 'typescript-tslint 'web-mode))
      (add-hook 'flycheck-mode-hook #'td/enable-tslint-web-mode)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package pyvenv
    :defer t
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package py-isort
    :ensure t
    :defer t
    :functions py-isort-before-save)

  (use-package python
    :mode (("\\.py\\'" . python-mode))
    :interpreter ("pipenv run python" . python-mode)
    :hook (before-save . py-isort-before-save))
#+END_SRC

** Haskell

I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
easy. There's also a catch-all IDE-like mode called =intero=, by the very
same folk who runs =stack=.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :mode (("\\.hs\\'" . haskell-mode))
    :bind (([remap haskell-mode-format-imports] . haskell-sort-imports))
    :config
    (setq haskell-program-name "stack repl"))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :defer t)
#+END_SRC

** PureScript

I started using PureScript for all my frontend works.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package purescript-mode
    :ensure t
    :mode (("\\.purs\\'" . purescript-mode))
    :hook ((purescript-mode . turn-on-purescript-indentation)
           (purescript-mode . td/turn-off-evil-auto-indent))
    :config
    (defun purescript-doc-current-info ()))

  (use-package psc-ide
    :ensure t
    :hook (purescript-mode . psc-ide-mode))
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :mode (("\\.go$" . go-mode)))
#+END_SRC

** Swift

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package swift-mode
    :ensure t
    :mode (("\\.swift" . swift-mode)))
#+END_SRC

** Solidity

#+BEGIN_SRC emacs-lisp
  (use-package solidity-mode
    :ensure t
    :mode (("\.sol$" . solidity-mode)))
#+END_SRC

** Java

** Docker

I use Docker for almost every project now, it is useful even just for setting up
consistent development environment across the team. I use =docker= package to
manage Docker images and containers.

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode ("Dockerfile$" . dockerfile-mode))
#+END_SRC


** Misc

These are supports for other stuffs that I used:

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package nix-mode
    :ensure t
    :mode (("\\.nix$" . nix-mode))
    :config
    (exec-path-from-shell-copy-env "NIX_REMOTE"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode
    :ensure t
    :mode (".*nginx.*\\.conf$" . nginx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode)
           ("\\.sls$" . yaml-mode)
           ("^master$" . yaml-mode)
           ("^roster$" . yaml-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :config
    (setq groovy-indent-offset 2))
#+END_SRC


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time loging

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :bind (("C-c o c" . org-occur-in-agenda-files))
    :hook (org-mode . org-indent-mode)
    :config
    (setq org-directory "~/Desktop/"
          org-default-notes-file (expand-file-name "inbox.org" org-directory)
          org-agenda-files (list org-directory)
          org-agenda-skip-unavailable-files t
          org-hide-leading-stars t
          org-refile-targets (list '("~/Desktop/archive.org" . (:level . 1)))

          org-startup-with-inline-images t

          org-todo-keywords
          '((sequence "[ ](t)" "[-](p)" "[?](m)" "|" "[X](d)")
            (sequence "TODO(T)" "|" "DONE(D)")
            (sequence "NEXT(n)" "ACTIVE(a)" "WAITING(w)" "LATER(l)" "|" "CANCELLED(c)"))
          org-log-done 'time

          org-src-fontify-natively t))
#+END_SRC

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/cancelled)
- But don't have any todo items

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :config
    (setq org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-stuck-projects
          '("+project+LEVEL=1/-WAITING-DONE-CANCELLED" ("TODO" "WAITING") nil "")))
#+END_SRC

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

** Archive

I also use =org-board= to have an offline pin-board with org-mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-board
    :ensure t
    :defer t
    :bind-keymap ("C-c b" . org-board-keymap))
#+END_SRC

** Literate programming

Org Babel for literate programming and API documentation.

#+BEGIN_SRC emacs-lisp
  (use-package ob-http
    :defer t
    :ensure t)

  (use-package ob-core
    :defer t
    :config
    (setq org-confirm-babel-evaluate nil))

  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :hook (org-babel-after-execute . org-display-inline-images)
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t)
       (python . t)
       (shell . t))))
#+END_SRC

** Spell checking

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :bind ("<f8>" . ispell-word)
    :config
    (setq ispell-program-name "aspell"
          ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary")
          ispell-skip-html t
          ispell-silently-savep t
          ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :hook (org-mode . flyspell-mode))
#+END_SRC


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        visible-bell nil
        ring-bell-function 'ignore
        scroll-preserve-screen-position t
        scroll-margin 8)
#+END_SRC

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+BEGIN_SRC emacs-lisp
  (setq-default
   fringes-outside-margins t
   ;; line-spacing 4
   default-frame-alist
   '((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     ;; (font . "Hack 14")
     ;; (font . "Monaco 14")
     (font . "Menlo 16")
     ;; (font . "Source Code Pro 16")
     ;; (font . "Hasklig 14")
     ;; (font . "Fira Code 14")
     (top . 0) (left . 480)
     (width . 96) (height . 96)
     (vertical-scroll-bars . nil)
     (menu-bar-lines . 0)
     (tool-bar-lines . 0)))

  (blink-cursor-mode -1)
#+END_SRC

Enable ligatures, only available in railwaycat Mac port.

#+BEGIN_SRC emacs-lisp :tangle no
  (mac-auto-operator-composition-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-use-native-fullscreen nil)
#+END_SRC

Truncate lines:

#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(vertical-border ((t (:foreground "#000" :background "#000"))))
   ;;'(highlight ((t (:inherit region))))
   ;;'(sp-pair-overlay-face ((t (:inherit region))))
   ;;'(font-lock-string-face ((t (:slant normal))))

   ;;'(line-number ((t (:height 120 :inherit font-lock-comment-face))))
   ;;'(line-number-current-line ((t (:height 120 :bold nil))))
   ;;'(fringe ((t (:inherit nil))))
   ;;'(mode-line ((t (:box nil))))
   ;;'(mode-line-inactive ((t (:box nil))))

   '(indent-guide-face ((t (:inherit font-lock-comment-face))))
   '(web-mode-variable-name-face ((t (:inherit default))))

   '(diff-hl-insert ((t (:inherit nil :background nil :foreground "#81af34"))))
   '(diff-hl-delete ((t (:inherit nil :background nil :foreground "#ff0000"))))
   '(diff-hl-change ((t (:inherit nil :background nil :foreground "#deae3e"))))

   ;; tango-plus
   '(font-lock-keyword-face ((t (:weight normal))))
   '(font-lock-string-face ((t (:slant normal))))
   '(font-lock-constant-face ((t (:slant normal))))
   '(font-lock-comment-face ((t (:slant normal))))
   '(font-lock-comment-delimiter-face
     ((t (:inherit font-lock-comment-face :foreground nil :slant normal))))
   '(line-number ((t (:inherit font-lock-comment-face :height 120))))
   '(line-number-current-line ((t (:inherit font-lock-comment-face :height 120 :bold t))))

   ;; nord
   ;;'(haskell-operator-face ((t (:inherit font-lock-preprocessor-face :weight normal)))) ; nord10
   ;;'(highlight-numbers-number ((t (:inherit nil :foreground "#B48EAD")))) ; nord15
   ;; '(diff-hl-insert ((t (:inherit nil :background nil :foreground "#A3BE8C"))))
   ;; '(diff-hl-delete ((t (:inherit nil :background nil :foreground "#BF616A"))))
   ;; '(diff-hl-change ((t (:inherit nil :background nil :foreground "#EBCB8B"))))

   ;; spacegray
   ;; '(web-mode-jsx-depth-1-face ((t (:background "#242930"))))
   ;; '(web-mode-jsx-depth-2-face ((t (:background "#1d2126"))))
   ;; '(web-mode-jsx-depth-3-face ((t (:background "#16191c"))))
   ;; '(web-mode-jsx-depth-4-face ((t (:background "#0e1013"))))
   ;; '(web-mode-jsx-depth-5-face ((t (:background "#070809"))))
   )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :ensure t
    :defer t
    :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

I also have very good experience with *Tango Plus*. Its philosophy of not
getting in the way is interesting.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tango-plus-theme
    :ensure t
    :init (load-theme 'tango-plus t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package soft-morning-theme
    :ensure t
    :init (load-theme 'soft-morning t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :init
    (eval-and-compile
      (setq doom-themes-enable-italic nil
            doom-spacegrey-brighter-modeline t
            doom-vibrant-brighter-modeline t)
      (load-theme 'doom-gruvbox t))
    :hook (org-mode . doom-themes-org-config))
#+END_SRC

I also have an alternate light-theme for backup or use in
presentation, which is *base16-github* from [[https://github.com/belak/base16-emacs][base16-themes]] package.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package base16-theme
    :ensure t)
#+END_SRC

Mode line

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :preface (setq sml/theme nil)
    :hook (after-init . sml/setup))
#+END_SRC

Show current function name in the mode line:

#+BEGIN_SRC emacs-lisp
  (which-function-mode t)
#+END_SRC

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (setq-default display-line-numbers-width 3)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'web-mode-hook #'display-line-numbers-mode)
#+END_SRC

The default line continuation indicator is too standout and distracting for me.

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b01000000
     #b10000000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
  (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :ensure t
    :commands (indent-guide-mode)
    :diminish indent-guide-mode
    :hook ((python-mode . indent-guide-mode)
           (yaml-mode . indent-guide-mode)
           (purescript-mode . indent-guide-mode)
           (haskell-mode . indent-guide-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (eval-and-compile
      (setq rainbow-delimiters-max-face-count 1)

      (custom-theme-set-faces
       'user
       '(rainbow-delimiters-unmatched-face ((t (:inherit error :background "#f00")))))))
#+END_SRC

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer t
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :init
    (eval-and-compile
      (define-fringe-bitmap 'td/diff-hl-bmp [#b11110000] 1 8 '(top t))
      (defun td/diff-hl-bmp-fn (type pos) 'td/diff-hl-bmp)

      (setq diff-hl-draw-borders nil
            ;diff-hl-side 'right
            diff-hl-fringe-bmp-function #'td/diff-hl-bmp-fn)

      (defun diff-hl-overlay-modified (ov after-p beg end &optional len)
        "Markers disappear and reapear is kind of annoying to me.")))
#+END_SRC


* Misc

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :defer t
    :config
    (setq dired-recursive-deletes 'always))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Google Chrome\" to reload active tab of window 1'"))

  (bind-key* "C-c b r" #'td/refresh-front-most-tab)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/cycle-themes ()
    (interactive)
    (let* ((current-theme (car custom-enabled-themes))
           (index (or (-elem-index current-theme (custom-available-themes)) 0))
           (next-theme (nth (+ 1 index) (custom-available-themes))))
      (disable-theme current-theme)
      (load-theme next-theme t)))

  (bind-key "C-c t n" #'td/cycle-themes)
#+END_SRC


* Init file generation

Where the magic happen!

#+BEGIN_SRC text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.emacs.d/init.el")) nil t)
  # End:
#+END_SRC
