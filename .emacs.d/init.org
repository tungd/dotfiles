#+title: Tung Dao
#+startup: overview
#+property: header-args :tangle yes :results silent

* Packages and initialization

  All the packages I used are from [[https://melpa.org][MELPA]]. However, I
  install them automatically with =use-package.el= instead of using =package.el=
  directly.

  #+BEGIN_SRC emacs-lisp
    (package-initialize)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  #+END_SRC

  Sometimes I write my own package, they are in the =~/.emacs.d/vendor=
  directory.

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
  #+END_SRC

  Use a dedicate custom file.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file 'noerror)
  #+END_SRC


* Defaults

  Sane, modern defaults:

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Tung Dao"
          user-mail-address "me@tungdao.com"
          default-input-method 'vietnamese-telex)

    (defalias 'yes-or-no-p 'y-or-n-p)

    (use-package better-defaults
      :ensure t
      :preface
      (setq-default show-paren-delay 0))
  #+END_SRC

  *NOTE*: I also set the delay right here since =better-defaults= loads
  =show-paren-mode=.

  #+BEGIN_SRC emacs-lisp
    (use-package smex
      :ensure t
      :init (smex-initialize))
  #+END_SRC


* Navigation

** Projects

   I use =projectile= to switch between projects and between files in
   the same project. When possible I will use the functions provided
   by Emacs, however the project facilities built-in in recent version
   of Emacs but it is still bare bone.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :diminish projectile-mode
       :init (projectile-mode t)
       :bind (
              ;; ("C-M-'" . projectile-find-file)
              )
       :config
       (setq projectile-globally-ignored-file-suffixes
             '("jpg" "png" "svg" "psd" "sketch" "afdesign"
               "pdf" "doc" "docx" "xls" "xlsx"
               "ttf" "otf" "woff"
               "rar" "zip" "min.js" "min.css" "map")))
   #+END_SRC

** Symbols

   For jumping to defined symbols (functions, classes, .etc), I use
   =dump-jump=. Mode specific support for this feature is at higher
   priority, when they fail =dump-jump= will be the fallback.

   The key bindings are:

   | Binding | Command                | Description    |
   |---------+------------------------+----------------|
   | =C-M-g= | =dump-jump-go=         | Jump to symbol |
   | =C-M-p= | =dump-jump-back=       | Back           |
   | =C-M-q= | =dump-jump-quick-look= | Quick look     |

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :ensure t
       :init (dumb-jump-mode t))
   #+END_SRC

** Ivy

   Ivy is a nice completion package, however the main reason I use it over =ido=
   is that I can make its popup appear at the top of the window.

   #+BEGIN_SRC emacs-lisp
     (ido-mode -1)

     (use-package ivy
       :init (ivy-mode t)
       :diminish ivy-mode
       :bind (("C-M-o" . ivy-switch-buffer))
       :config
       (progn
         (setq ivy-format-function 'ivy-format-function-arrow
               ivy-count-format ""
               ivy-use-virtual-buffers t
               ivy-height 16
               projectile-completion-system 'ivy)

         (require 'ivy-popup)))

     (use-package counsel
       :ensure t
       :bind (([remap find-file] . counsel-find-file)
              ([remap ido-find-file] . counsel-find-file)
              ([remap execute-extended-command] . counsel-M-x)
              ("C-M-'" . counsel-git)
              ("M-m" . counsel-M-x)
              ("C-c i" . counsel-imenu)))
   #+END_SRC


* General Editing

  Basic settings:

  #+BEGIN_SRC emacs-lisp
    (setq-default
     tab-width 2
     indent-tabs-mode nil)
  #+END_SRC

  Editing utilities:

  #+BEGIN_SRC emacs-lisp
    (bind-key [remap delete-horizontal-space] #'cycle-spacing)

    (use-package crux
      :ensure t
      :commands (crux-sudo-edit
                 crux-switch-to-previous-buffer
                 crux-top-join-line
                 crux-cleanup-buffer-or-region
                 crux-kill-whole-line)
      :bind (("C-M-]" . crux-switch-to-previous-buffer)
             ("M-J" . crux-top-join-line)
             ("M-=" . crux-cleanup-buffer-or-region)
             ("C-M-k" . crux-kill-whole-line)))

    (use-package comment-dwim-2
      :ensure t
      :bind ([remap comment-dwim] . comment-dwim-2)
      :config (setq comment-style 'multi-line))
  #+END_SRC

  Create directory for the file if not exists:

  #+BEGIN_SRC emacs-lisp
    (defun td/before-save-make-directories ()
      (let ((dir (file-name-directory buffer-file-name)))
        (when (and buffer-file-name (not (file-exists-p dir)))
          (make-directory dir t))))

    (add-hook 'before-save-hook #'td/before-save-make-directories)
  #+END_SRC

  Make the file executable if starting with "shebang":

  #+BEGIN_SRC emacs-lisp
    (defun td/after-save-auto-chmod ()
      (when (and (> (length (buffer-string)) 5)
                 (string-equal "#!" (buffer-substring-no-properties 1 4)))
        (shell-command
         (format "chmod u+x %s"
                 (shell-quote-argument (buffer-file-name))))))

    (add-hook 'after-save-hook #'td/after-save-auto-chmod)
  #+END_SRC

** Long lines

  Long lines are annoying. Auto wrap all texts at 80.

  #+BEGIN_SRC emacs-lisp
    (setq-default
     comment-auto-fill-only-comments t
     fill-column 80)

    (add-hook 'text-mode-hook #'turn-on-auto-fill)
    (add-hook 'prog-mode-hook #'turn-on-auto-fill)
  #+END_SRC

** Whitespace

  Cleanup whitespaces automatically on save.

  #+BEGIN_SRC emacs-lisp
    (use-package whitespace
      :commands (whitespace-cleanup)
      :init (add-hook 'before-save-hook #'whitespace-cleanup))
  #+END_SRC

** TODO Alignment
** Parenthesis

  Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
  use =smart-parens= to manage them. However the command name use words from an
  arcane language :(, so I put together a table of human-readable description of
  the commands. All key bindings are started with =M-s=.

  | Bindings  | Command                | Description                                         |
  |-----------+------------------------+-----------------------------------------------------|
  | =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
  | =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
  | =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
  | =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

  NOTE: This package is huge, I'm still learning it.

  #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t
      :diminish smartparens-mode
      :init (add-hook 'prog-mode-hook #'smartparens-mode)
      :bind (("M-s DEL" . sp-splice-sexp)
             ("M-S" . sp-rewrap-sexp)
             ("M-s <right>" . sp-slurp-hybrid-sexp)
             ("M-s <left>" . sp-forward-barf-sexp)
             ("C-M-a" . sp-beginning-of-sexp)
             ("C-M-e" . sp-end-of-sexp)
             ("M-K" . sp-kill-sexp))
      :config
      (set-face-attribute 'sp-pair-overlay-face nil :inherit 'region)
      (sp-pair "{" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "[" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "(" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
  #+END_SRC

** Undo
** Snippets


* Programming

** Auto completion

   I use auto completion sparingly. Mostly because many of the programing
   language support package use =company= for some of their functionalities. To
   be fair, I'd like these mode to support Emacs's standard
   =completion-at-point-functions= interface.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :diminish company-mode
       :bind ("M-/" . company-complete-common-or-cycle)
       :init (global-company-mode t)
       :config
       (progn
         (use-package company-buffer-line
           :commands (company-same-mode-buffer-lines)
           :bind ("C-x C-l" . company-same-mode-buffer-lines))

         (setq company-minimum-prefix-length 2
               company-require-match nil
               company-idle-delay nil
               company-tooltip-align-annotations t
               company-frontends
               '(company-pseudo-tooltip-unless-just-one-frontend
                 company-echo-metadata-frontend)
               company-backends
               '((company-dabbrev-code
                  :with
                  company-capf
                  company-yasnippet)))

         (bind-keys :map company-active-map
                    ("<tab>" . company-complete-common-or-cycle)
                    ("C-n" . company-select-next-or-abort)
                    ("C-p" . company-select-previous-or-abort))))
   #+END_SRC

** Error checking

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :defer t
       :init (global-flycheck-mode t)
       :config
       (progn
         (setq-default flycheck-disabled-checkers
                       '(scss))

         ;; Disable `js2-mode' built-in error checker
         (eval-after-load 'js2-mode
           '(setq js2-mode-show-parse-errors nil))

         (setq flycheck-checkers
               (--remove (eq it 'emacs-lisp-checkdoc) flycheck-checkers))))
   #+END_SRC

** Version Control

   Git has won the version control war, everyone uses Git now. Emacs'
   built-in VC has great support for git but Magit is godsend.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :config
       (setq magit-display-buffer-function
             #'magit-display-buffer-fullframe-status-v1))
   #+END_SRC

** Compile

   I use =compile= not only for compilation but also as a generic method to run
   repetitive tasks. For example, I to run unit tests repeatedly, I first run
   =M-x compile= with the test commands. Subsequence =recompile= call will
   re-run the tests.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c m" #'recompile)
   #+END_SRC

** Web Development

   Not programming per-se. I use =web-mode= for all my templating-related
   editing, including PHP, since I rarely write PHP anymore.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :defer t
       :mode (("\\.html" . web-mode)
              ("\\.j2" . web-mode)
              ("\\.jinja2" . web-mode)
              ("\\.php" . web-mode))
       :init (add-hook 'web-mode-hook #'emmet-mode)
       :config
       (progn
         (add-hook 'web-mode-hook #'turn-off-auto-fill)

         (setq web-mode-markup-indent-offset 2
               web-mode-css-indent-offset 2
               web-mode-code-indent-offset 2)))
   #+END_SRC

   Also, I can't live without Emmet.

   #+BEGIN_SRC emacs-lisp
     (use-package emmet-mode
       :ensure t
       :diminish emmet-mode
       :commands emmet-mode
       :init
       (progn
         (defun td/emmet-jsx-mode ()
           (interactive)
           (emmet-mode t)
           (setq-local emmet-expand-jsx-className? t))

         (add-hook 'sgml-mode-hook #'emmet-mode)
         (add-hook 'web-mode-hook #'emmet-mode)
         (add-hook 'css-mode-hook #'emmet-mode)
         (add-hook 'js2-jsx-mode-hook #'td/emmet-jsx-mode))
       :config
       (progn
         (setq emmet-indentation 2
               emmet-preview-default nil
               emmet-insert-flash-time 0.1)

         (defun td/hide-emmet-preview-tooltip ()
           (overlay-put emmet-preview-output 'before-string nil))

         (advice-add 'emmet-preview
                     :after #'td/hide-emmet-preview-tooltip)))
   #+END_SRC

** CSS

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode
       :defer t
       :config
       (setq css-indent-offset 2))
   #+END_SRC

** TODO JavaScript
** TODO Python
** TODO Elxir
** TODO Haskell
** PureScript

   I started using PureScript for all my frontend works.

   #+BEGIN_SRC emacs-lisp
     (use-package purescript-mode
       :ensure t
       :mode (("\\.purs$" . purescript-mode))
       :config
       (progn
         (defun purescript-doc-current-info ())

         (add-hook 'purescript-mode-hook #'turn-on-purescript-indentation)

         (use-package psc-ide
           :ensure t
           :init (add-hook 'purescript-mode-hook #'psc-ide-mode))))
   #+END_SRC

** Misc

   These are supports for other stuffs that I used:

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode
       :ensure t
       :mode ("\\.nix$" . nix-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t
       :mode ("Dockerfile$" . dockerfile-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode
       :ensure t
       :mode ("\\.fish$" . fish-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package nginx-mode
       :ensure t
       :mode (".*nginx.*\\.conf$" . nginx-mode))
   #+END_SRC


* Document and management

  I use Org for almost everything. Blogging, task management, API documentation,
  literate programming.

** Tracking and tasks management

   I tried many management tools: Wunderlist, Todoist, Google Calendar
   .etc. However all of them are missing something really crucial for me. For
   example Wunderlist has agenda overview, but lacks adding note to
   tasks. Evernote has execllent note support, but their project management is
   just barebone, not much than a todo list.

   Org on the other hand lacks notification and ubiquitous access. I'm looking
   for a solution though.

   Here's my basic Org setup:

   - A default =inbox.org= on Desktop for tasks capturing and project management
   - Nicer display with inline images
   - Enable GTD todo keyword sequence and time loging

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :bind (("C-c o a" . org-agenda)
              ("C-c o t" . org-todo-list))
       :config
       (setq org-directory "~/Desktop/"
             org-default-notes-file (expand-file-name "inbox.org" org-directory)
             org-agenda-files (list org-directory user-emacs-directory)
             org-agenda-skip-unavailable-files t

             org-startup-with-inline-images t

             org-todo-keywords
             '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "|" "CANCELED(c@)" "DONE(d!)"))
             org-log-done 'time))
   #+END_SRC

   Agenda overview and filtering.

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :config
       (setq org-agenda-restore-windows-after-quit t
             org-agenda-window-setup 'current-window))
   #+END_SRC

*** TODO Warn if a project doesn't have at least one TODO (GTD next action) tasks


** Literate programming

   Org Babel for literate programming and API documentation.

   #+BEGIN_SRC emacs-lisp
     (use-package ob-core
       :defer t
       :config
       (setq org-confirm-babel-evaluate nil))

     (use-package ob-http
       :ensure t
       :defer t
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (http . t))))
   #+END_SRC

** Note taking

** Blogging

   #+BEGIN_SRC emacs-lisp

   #+END_SRC

* Look and feel

  I love eye candy <3. I put quite a lot of efforts to make Emacs look
  the way I liked.

  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen t
          visible-bell nil
          ring-bell-function 'ignore)
  #+END_SRC

  Default window configuration: half-left of the screen, no scroll
  bars, no menu bars, no cursor blinking. And btw, nothing beats the
  classic Monaco, not even "Source Code Pro" by Adobe.

  #+BEGIN_SRC emacs-lisp
    (setq-default
     fringes-outside-margins t
     default-frame-alist
     '((font . "Monaco 13")
       (top . 0) (left . 640)
       (width . 100) (height . 64)
       (vertical-scroll-bars . nil)
       (menu-bar-lines . 0)
       (tool-bar-lines . 0)
       (right-fringe . 0)))

    (blink-cursor-mode -1)
  #+END_SRC

  My theme of choice is *Brin* from the exellent [[https://github.com/owainlewis/emacs-color-themes][sublime-themes]]
  collection.

  #+BEGIN_SRC emacs-lisp
    (use-package sublime-themes
      :ensure t
      :init (load-theme 'brin t)
      :config
      (progn
        ;; Some tweak to the theme
        (set-face-attribute 'font-lock-comment-delimiter-face nil
                            :foreground nil
                            :inherit font-lock-comment-face)

        ;; Dark vertical border
        (set-face-attribute 'vertical-border nil
                            :foreground "#000" :background "#000")

        (eval-after-load 'nlinum
          '(set-face-attribute 'linum nil :height 110))))
  #+END_SRC

  I also have an alternate light-theme for backup or use in
  presentation, which is *base16-github* from [[https://github.com/belak/base16-emacs][base16-themes]] pacakge.

  #+BEGIN_SRC emacs-lisp
    (use-package base16-theme
      :ensure t)
  #+END_SRC

  Mode line

  #+BEGIN_SRC emacs-lisp
    (use-package smart-mode-line
      :ensure t
      :init (sml/setup))
  #+END_SRC

  Line and column numbers, which I find only helpful when tracking
  down compiler error :(.

  #+BEGIN_SRC emacs-lisp
    (column-number-mode t)

    (use-package nlinum
      :ensure t
      :init
      (when (display-graphic-p)
        (add-hook 'prog-mode-hook #'nlinum-mode))
      :config
      (setq nlinum-format " %3d  "))
  #+END_SRC

  The default line continuation indicator is too standout and distracting for me.

  #+BEGIN_SRC emacs-lisp
    (define-fringe-bitmap 'halftone
      [#b01000000
       #b10000000]
      nil nil '(top t))

    (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
    (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
  #+END_SRC


* Init file generation

  Where the magic happen!

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:
