#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle yes :results silent

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I
install them automatically with =use-package.el= instead of using =package.el=
directly.

I'm also trying out some of the start-up optimization tips from Doom.

#+BEGIN_SRC emacs-lisp
  ;; (defvar file-name-handler-alist-orig file-name-handler-alist)

  (setq package-enable-at-startup nil
        ;; file-name-handler-alist nil
        message-log-max 16384
        ;gc-cons-threshold 402653184
        ;gc-cons-percentage 0.6
        auto-window-vscroll nil)

  (setq-default bidi-display-reordering nil)

  ;; (add-hook 'after-init-hook
  ;;           (lambda ()
  ;;             (setq file-name-handler-alist file-name-handler-alist-orig
  ;;                   gc-cons-threshold 800000
  ;;                   gc-cons-percentage 0.1)
  ;;             (garbage-collect)) t)
#+END_SRC

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+END_SRC

Really do the loading:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "use-package/"))

  (eval-when-compile (require 'use-package))

  (require 'bind-key)

  (package-initialize)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  (use-package benchmark-init
    :ensure t
    :init (benchmark-init/activate)
    :hook (after-init . benchmark-init/deactivate))

  (use-package diminish :ensure t)
#+END_SRC

Use a dedicate custom file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+END_SRC


* Defaults

Personal information that some package use:

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Tung Dao"
        user-mail-address "me@tungdao.com"
        default-input-method 'vietnamese-telex)
  (defvar personal-keybindings nil)
#+END_SRC

Less verbose choice:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-command-modifier 'meta
        ns-option-modifier 'super
        trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :hook (after-init . smex-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq locate-command "mdfind")
#+END_SRC

** Server

#+BEGIN_SRC emacs-lisp
  (defun td/ensure-server-running ()
    (require 'server)
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook #'td/ensure-server-running)
#+END_SRC


* Navigation

** File position

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :hook (after-init . save-place-mode))
#+END_SRC

** Projects

I use =projectile= to switch between projects and between files in
the same project. When possible I will use the functions provided
by Emacs, however the project facilities built-in in recent version
of Emacs but it is still bare bone.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :hook (after-init . projectile-mode)
    :config
    (setq projectile-globally-ignored-file-suffixes
          '("jpg" "png" "svg" "psd" "sketch" "afdesign"
            "pdf" "doc" "docx" "xls" "xlsx"
            "ttf" "otf" "woff"
            "rar" "zip" "min.js" "min.css" "map")))
#+END_SRC

** Symbols

For jumping to defined symbols (functions, classes, .etc), I use
=dump-jump=. Mode specific support for this feature is at higher
priority, when they fail =dump-jump= will be the fallback.

The key bindings are:

| Binding | Command                | Description    |
|---------+------------------------+----------------|
| =C-M-g= | =dump-jump-go=         | Jump to symbol |
| =C-M-p= | =dump-jump-back=       | Back           |
| =C-M-q= | =dump-jump-quick-look= | Quick look     |

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :hook (prog-mode . dumb-jump-mode))
#+END_SRC

** Ivy

Ivy is a nice completion package, however the main reason I use it over =ido=
is that I can make its popup appear at the top of the window.

#+BEGIN_SRC emacs-lisp
  (ido-mode -1)

  (use-package ivy
    :diminish ivy-mode
    :hook ((after-init . ivy-mode)
           (ivy-mode . (lambda () (require 'ivy-popup))))
    :bind (("C-M-o" . ivy-switch-buffer))
    :config
    (setq ivy-format-function 'ivy-format-function-arrow
          ivy-count-format ""
          ivy-use-virtual-buffers t
          ivy-height 16
          projectile-completion-system 'ivy)
    (require 'counsel))

  (use-package counsel
    :ensure t
    :bind (([remap find-file] . counsel-find-file)
           ([remap ido-find-file] . counsel-find-file)
           ([remap execute-extended-command] . counsel-M-x)
           ("C-M-'" . counsel-git)
           ("M-\"" . counsel-git-grep)
           ("M-m" . counsel-M-x)
           ("C-c i" . counsel-imenu)))

  (use-package imenu
    :hook (imenu-after-jump . recenter-top-bottom))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ivy-posframe
    :ensure t
    :defer t
    :config
    (eval-and-compile
      (defun ivy-posframe-display-at-frame-top-left (str)
        (ivy-posframe--display str #'posframe-poshandler-window-top-left-corner))
      (ivy-posframe-setup)
      (setq ivy-display-function #'ivy-posframe-display-at-frame-top-left))
    :hook (ivy-mode . (lambda () (require 'ivy-posframe))))
#+END_SRC

Use =historian.el= to sort ivy completion based on frequency - similar to smex.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-historian
    :ensure t
    :defer t
    :hook (ivy-mode . ivy-historian-mode))
#+END_SRC


* Window Management

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package shackle
    :ensure t
    :init (add-hook 'after-init-hook 'shackle-mode)
    :config
    (setq shackle-default-alignment 'below
          shackle-default-rule
          '((compilation-mode :align 'below))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package window-numbering
    :ensure t
    :hook (after-init . window-numbering-mode)
    :config
    (eval-and-compile
      (defun td/window-numbering-get-number-string (number-string)
        (format "[%s] " number-string))
      (advice-add 'window-numbering-get-number-string
                  :filter-return #'td/window-numbering-get-number-string)))
#+END_SRC


* General Editing

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

Basic settings:

#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width 2
   indent-tabs-mode nil
   require-final-newline t
   reb-re-syntax 'string)
#+END_SRC

Editing utilities:

#+BEGIN_SRC emacs-lisp
  (bind-key [remap delete-horizontal-space] #'cycle-spacing)

  (use-package crux
    :ensure t
    :commands (crux-sudo-edit
               crux-switch-to-previous-buffer
               crux-top-join-line
               crux-cleanup-buffer-or-region
               crux-kill-whole-line)
    :bind (("C-M-]" . crux-switch-to-previous-buffer)
           ("M-J" . crux-top-join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save))

  (bind-key "C-c C-k" #'kill-this-buffer)

  (use-package comment-dwim-2
    :ensure t
    :bind ([remap comment-dwim] . comment-dwim-2)
    :config (setq comment-style 'multi-line))
#+END_SRC

Automatically apply external changes: This is debatable, from my own
experience it is helpful.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :diminish auto-revert-mode
    :hook (after-init . global-auto-revert-mode))
#+END_SRC

Automatically save buffers when focus out:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun td/save-all-buffers ()
    (interactive)
    (save-some-buffers t))

  (add-hook 'focus-out-hook 'td/save-all-buffers)
#+END_SRC

Create directory for the file if not exists:

#+BEGIN_SRC emacs-lisp
  (defun td/before-save-make-directories ()
    (let ((dir (file-name-directory buffer-file-name)))
      (when (and buffer-file-name (not (file-exists-p dir)))
        (make-directory dir t))))

  (add-hook 'before-save-hook #'td/before-save-make-directories)
#+END_SRC

Make the file executable if starting with "shebang":

#+BEGIN_SRC emacs-lisp
  (defun td/after-save-auto-chmod ()
    (when (and (> (length (buffer-string)) 5)
               (string-equal "#!" (buffer-substring-no-properties 1 4)))
      (shell-command
       (format "chmod u+x %s"
               (shell-quote-argument (buffer-file-name))))))

  (add-hook 'after-save-hook #'td/after-save-auto-chmod)
#+END_SRC

I was a pretty die-hard Vim fanboy, let's bring back the memory.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :defer t
    :hook (after-init . evil-mode)
    :bind (:map evil-normal-state-map ("M-." . xref-find-definitions))
    :config
    (setq evil-cross-lines t
          evil-ex-substitute-global t))

  (use-package evil-surround
    :ensure t
    :defer t
    :after evil
    :hook (evil-mode . global-evil-surround-mode))

  (use-package evil-visualstar
    :ensure t
    :defer t
    :after evil
    :hook (evil-mode . global-evil-visualstar-mode))
#+END_SRC

** Search and replace

Anzu command names are confusing, at-cursor means initial string, while thing
means boundary.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :diminish anzu-mode
    :hook (after-init . global-anzu-mode)
    :bind (([remap query-replace] . anzu-query-replace-regexp)
           ;("C-c C-r" . anzu-query-replace-at-cursor)
           ("M-r" . anzu-replace-at-cursor-thing)
           ("C-M-r" . td/anzu-replace-at-cursor-thing-in-buffer))
    :config
    (defun td/anzu-replace-at-cursor-thing-in-buffer ()
      "This does not actually query, but it's OK for me."
      (interactive)
      (let ((anzu-replace-at-cursor-thing 'buffer))
        (call-interactively 'anzu-query-replace-at-cursor-thing))))
#+END_SRC

Also define "buffer-at-point" so that we can do query-replace in the whole
buffer without having to jump to the beginning.

#+BEGIN_SRC emacs-lisp
  (use-package thingatpt
    :after (anzu)
    :config
    (eval-and-compile
      (defun td/bounds-of-buffer-at-point ()
        (cons (point-min) (point-max)))

      (put 'buffer 'bounds-of-thing-at-point 'td/bounds-of-buffer-at-point)
      (put 'buffer 'beginning-op 'beginning-of-buffer)
      (put 'buffer 'end-op 'end-of-buffer)))
#+END_SRC

I also use ISearch for navigation. In such cases I want to put the cursor at
the beginning of the match, not the end.

#+BEGIN_SRC emacs-lisp
  (setq lazy-highlight-initial-delay 0)

  (defun td/isearch-exit-goto-match-beginning ()
    (interactive)
    (when (and isearch-forward isearch-other-end)
      (goto-char isearch-other-end)))

  (add-hook 'isearch-mode-end-hook #'td/isearch-exit-goto-match-beginning)
  (advice-add 'isearch-exit :after #'td/isearch-exit-goto-match-beginning)
#+END_SRC

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+BEGIN_SRC emacs-lisp
  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'prog-mode-hook #'turn-on-auto-fill)
#+END_SRC

Sometimes long lines are inevitable though, as I do have to manually edit
exported SVG and minified JS :(. In those cases prevent them from making Emacs
slow:

#+BEGIN_SRC emacs-lisp
  (use-package so-long
    :hook (after-init . so-long-enable))
#+END_SRC

** Whitespace

Cleanup whitespaces automatically on save.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup))
#+END_SRC

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
use =smart-parens= to manage them. However the command name use words from an
arcane language :(, so I put together a table of human-readable description of
the commands. All key bindings are started with =M-s=.

| Bindings  | Command                | Description                                         |
|-----------+------------------------+-----------------------------------------------------|
| =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
| =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
| =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
| =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

NOTE: This package is huge, I'm still learning it.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :hook ((prog-mode . smartparens-mode)
           (prog-mode . show-smartparens-mode))
    :bind (("M-s DEL" . sp-splice-sexp)
           ("M-S" . sp-rewrap-sexp)
           ("M-s <right>" . sp-slurp-hybrid-sexp)
           ("C-S-f" . sp-slurp-hybrid-sexp)
           ("M-s <left>" . sp-forward-barf-sexp)
           ("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("M-K" . sp-kill-sexp)
           ("M-]" . sp-select-next-thing))
    :config
    (sp-pair "{" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("M--" . er/expand-region))

  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)
#+END_SRC

** Undo

By default Emacs doesn't even have redo!

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :hook (after-init . global-undo-tree-mode))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :hook (after-init . yas-global-mode)
    :init
    (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
    :config
    (eval-and-compile
      (setq yas-prompt-functions
            '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
            yas-verbosity 1)

      ;; I'm an old Emacs hacker. I like the abbrev-way and bind yas-expand to
      ;; SPC.
      (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

      (unbind-key "TAB" yas-minor-mode-map)
      (unbind-key "<tab>" yas-minor-mode-map)))
#+END_SRC

** Alignment

#+BEGIN_SRC emacs-lisp
  (use-package align
    :defer t
    :bind (("C-c =" . align))
    :config
    (eval-and-compile
      (add-to-list 'align-rules-list
                   '(js-object-props
                     (modes . '(js-mode js2-mode web-mode))
                     (regexp . "\\(\\s-*\\):")
                     (spacing . 0)))
      (add-to-list 'align-rules-list
                   '(css-declaration
                     (modes . '(css-mode))
                     (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                     (group 1)))
      (add-to-list 'align-rules-list
                   '(haskell-record-fields
                     (modes . '(haskell-mode))
                     (regexp . "\\(\\s-*\\)::")
                     (spacing . 1)))
      (add-to-list 'align-rules-list
                   '(haskell-aeson-fields
                     (modes . '(haskell-mode))
                     (regexp . "\\(\\s-*\\).=")
                     (spacing . 1)))
      (add-to-list 'align-rules-list
                   '(ruby-hash
                     (modes . '(ruby-mode))
                     (regexp . "\\(\\s-*\\)=>")
                     (spacing . 1)))))
#+END_SRC

** Recent files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :defer t
    :config
    (setq recentf-max-saved-items 128
          recentf-exclude
          '("/auto-install/" ".recentf" "/repos/" "/elpa/"
            "\\.mime-example" "\\.ido.last" "COMMIT_EDITMSG"
            ".gz" "~$" "/tmp/" "/ssh:" "/sudo:" "/scp:")))
#+END_SRC


* Shell and remote

** EShell

#+BEGIN_SRC emacs-lisp
  (defun td/with-face (str &rest properties)
    (propertize str 'face properties))

  (use-package eshell
    :defer t
    :config
    (eval-and-compile
      (defun td/eshell-pwd ()
        (replace-regexp-in-string
         (regexp-quote (expand-file-name "~"))
         "~"
         (eshell/pwd)))

      (defun td/eshell-prompt ()
        (format
         "\n%s@%s in %s\n%s "
         (td/with-face user-login-name :foreground "#dc322f")
         (td/with-face (or (getenv "HOST") (system-name)) :foreground "#b58900")
         (td/with-face (td/eshell-pwd) :foreground "#859900")
         (if (= (user-uid) 0) (td/with-face "#" :foreground "red") "$")))

      (defalias 'eshell/e 'find-file-other-window)

      (defun eshell/open (args)
        (interactive)
        (shell-command
         (concat (cl-case system-type
                   ((darwin) "open")
                   ((windows-nt) "start")
                   (t "xdg-open"))
                 (format " %s" args))))

      (use-package em-prompt
        :defer t
        :config
        (setq eshell-prompt-function #'td/eshell-prompt
              eshell-prompt-regexp "^[^#$\\n]*[#$] "
              eshell-highlight-prompt nil))))
#+END_SRC


** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (eval-and-compile
      (setq password-cache-expiry nil
            tramp-debug-buffer t
            tramp-default-method "ssh"
            tramp-verbose 2)

      (add-to-list 'auth-sources "~/.emacs.d/authinfo.gpg")
      (setq ange-ftp-netrc-filename "~/.emacs.d/authinfo.gpg")))
#+END_SRC


* Programming

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :defer t
    :config
    (setq lsp-highlight-symbol-at-point nil))
#+END_SRC

** Auto completion

I use auto completion sparingly. Mostly because many of the programing
language support package use =company= for some of their functionalities. To
be fair, I'd like these mode to support Emacs's standard
=completion-at-point-functions= interface.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish company-mode
    :bind (("M-/" . company-complete-common-or-cycle)
           ("C-x C-p" . company-files)
           :map company-active-map
           ("<tab>" . company-complete-common-or-cycle)
           ("C-n" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort))
    :hook (after-init . global-company-mode)
    :config
    (setq company-minimum-prefix-length 2
          company-require-match nil
          company-idle-delay nil
          company-tooltip-align-annotations t
          company-echo-delay 0
          company-frontends
          '(company-pseudo-tooltip-unless-just-one-frontend
            company-echo-metadata-frontend)
          company-backends
          '((company-capf company-dabbrev-code
                          :with
                          company-yasnippet
                                          ;company-dict
                                          ;company-web-html
                          company-files))))

  (use-package company-buffer-line
    :commands (company-same-mode-buffer-lines)
    :bind ("C-x C-l" . company-same-mode-buffer-lines))

  (use-package company-statistics
    :ensure t
    :defer t
    :hook (global-company-mode . company-statistics-mode))
#+END_SRC


** Error checking

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands (flycheck-mode)
    :functions (flycheck-add-mode flycheck-add-next-checker)
    :init (add-hook 'prog-mode-hook #'flycheck-mode)
    :config
    (setq-default flycheck-disabled-checkers '(scss emacs-lisp-checkdoc)))
#+END_SRC

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+END_SRC

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+BEGIN_SRC emacs-lisp
  (setq-default compilation-scroll-output 'first-error)
  (bind-key "C-c m" #'recompile)

  (defun td/compilation-hide-window-on-finish (buffer string)
    (if (and (string-match "compilation" (buffer-name buffer))
             (string-match "finished" string)
             (not (with-current-buffer buffer
                    (search-forward "warning" nil t)))
             (not (with-current-buffer buffer
                    (search-forward "Error" nil t))))
        (run-with-timer 1 nil #'delete-window (get-buffer-window buffer))))

  ;; (add-hook 'compilation-finish-functions #'td/compilation-hide-window-on-finish)
#+END_SRC

** Code folding

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hideshowvis
    :ensure t
    :init
    (add-hook 'hs-minor-mode-hook 'hideshowvis-enable))
#+END_SRC

** Web Development

Not programming per-se. I use =web-mode= for all my templating-related
editing, including PHP, since I rarely write PHP anymore.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html" . web-mode)
           ("\\.jsx" . web-mode)
           ("\\.tsx" . web-mode)
           ("\\.tpl" . web-mode)
           ("\\.erb" . web-mode)
           ("\\.tag" . web-mode)
           ("themes/.+\\.php" . web-mode)
           ("\\.hbs" . web-mode)
           ("\\.mustache" . web-mode))
    :init (add-hook 'web-mode-hook #'emmet-mode)
    :config
    (eval-and-compile
      (setq web-mode-markup-indent-offset 2
            web-mode-css-indent-offset 2
            web-mode-code-indent-offset 2
            web-mode-script-padding 2
            web-mode-style-padding 2)

      (add-hook 'web-mode-hook #'turn-off-auto-fill)

      (defun td/setup-web-mode ()
        (interactive)
        (when (string-suffix-p ".jsx" (buffer-file-name))
          (flycheck-add-mode 'javascript-eslint 'web-mode)))

      (add-hook 'web-mode-hook #'td/setup-web-mode)))
#+END_SRC

Also, I can't live without Emmet.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :diminish emmet-mode
    :commands emmet-mode
    :init
    (eval-and-compile
      (defun td/emmet-jsx-mode ()
        (interactive)
        (emmet-mode t)
        (setq-local emmet-expand-jsx-className? t))

      (add-hook 'sgml-mode-hook #'emmet-mode)
      (add-hook 'web-mode-hook #'emmet-mode)
      (add-hook 'css-mode-hook #'emmet-mode)
      (add-hook 'js2-jsx-mode-hook #'td/emmet-jsx-mode)
      (add-hook 'js-jsx-mode-hook #'td/emmet-jsx-mode))
    :config
    (eval-and-compile
      (setq emmet-indentation 2
            emmet-preview-default nil
            emmet-insert-flash-time 0.1)

      (defun td/hide-emmet-preview-tooltip ()
        (overlay-put emmet-preview-output 'before-string nil))

      (advice-add 'emmet-preview
                  :after #'td/hide-emmet-preview-tooltip)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+END_SRC

** PHP

#+BEGIN_SRC emacs-lisp
  (use-package php-mode
    :ensure t
    :mode (("\\.php" . php-mode))
    :config
    (setq php-mode-coding-style 'drupal))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css\\'"
    :config
    (setq css-indent-offset 2))

  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook (css-mode . rainbow-mode))
#+END_SRC

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try

#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-javascript-typescript
  ;;  :ensure t)

  (use-package js
    :mode (("\\.js$" . js-mode)
           ;("\\.jsx$" . js-jsx-mode)
           ("\\.json$" . js-mode)
           ("\\.eslintrc$" . js-mode))
    :config
    (setq js-indent-level 2
          js-indent-first-init 'dynamic
          js-switch-indent-offset 2
          js-enabled-frameworks '(javascript))
    ;; :preface
    ;; (progn
    ;;   (defun td/setup-js-mode ()
    ;;     (interactive)
    ;;     (require 'lsp-javascript-typescript)
    ;;     (lsp-javascript-typescript-enable))
    ;;   (add-hook 'js-mode-hook #'td/setup-js-mode))
    )

  (use-package add-node-modules-path
    :ensure t
    :defer t
    :init (add-hook 'js-mode-hook #'add-node-modules-path))
#+END_SRC

Well, I'm also on the TypeScript train lately, mostly because of the super
awesome StencilJS project.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package typescript-mode
    :ensure t
    :mode "\\.ts"
    :config
    (eval-and-compile
      (setq typescript-indent-level 2)
      (defun td/enable-tslint-web-mode ()
        (interactive)
        (flycheck-add-mode 'typescript-tslint 'web-mode))
      (add-hook 'flycheck-mode-hook #'td/enable-tslint-web-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package tide
    :ensure t
    :defer t
    :diminish t
    :preface
    (defun td/setup-tide-mode ()
      (interactive)
      (when (string-equal "tsx" (file-name-extension buffer-file-name))
        (tide-setup)
        ;; (flycheck-add-next-checker 'typescript-tide '(t . typescript-tslint) 'append)
        ;; (tide-hl-identifier-mode +1)
        ))
    :hook (web-mode . td/setup-tide-mode))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package pyvenv
    :defer t
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-python :ensure t)
  ;; (defun td/setup-python-mode ()
  ;;   (interactive)
  ;;   (require 'lsp-python)
  ;;   (lsp-python-enable))
  ;; (add-hook 'python-mode-hook #'td/setup-python-mode)

  (use-package py-isort
    :ensure t
    :defer t
    :functions py-isort-before-save)

  (use-package python
    :mode (("\\.py\\'" . python-mode))
    :interpreter ("pipenv run python" . python-mode)
    :config
    (add-hook 'before-save-hook 'py-isort-before-save))
#+END_SRC

** Haskell

I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
easy. There's also a catch-all IDE-like mode called =intero=, by the very
same folk who runs =stack=.

#+BEGIN_SRC emacs-lisp
  (defun td/turn-off-evil-auto-indent ()
    (setq-local evil-auto-indent nil))

  (use-package haskell-mode
    :ensure t
    :mode (("\\.hs\\'" . haskell-mode))
    :bind (([remap haskell-mode-format-imports] . haskell-sort-imports))
    :hook (haskell-mode . td/turn-off-evil-auto-indent)
    :config
    (setq haskell-program-name "stack repl"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package intero
    :ensure t
    :init
    (add-hook 'haskell-mode-hook #'intero-mode))
#+END_SRC

Dante is very nice in theory, however it's not working well with GHC 8.2 yet.

#+BEGIN_SRC emacs-lisp
  (use-package dante
    :ensure t
    :after haskell-mode
    :commands 'dante-mode
    :init
    (add-hook 'haskell-mode-hook 'dante-mode)
    :config
    (eval-and-compile
      (defun td/dante-setup-flycheck ()
        (flycheck-add-next-checker
         'haskell-dante '(warning . haskell-hlint)))

      (add-hook 'dante-mode-hook #'td/dante-setup-flycheck)))
#+END_SRC

LSP Haskell is another viable option.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-haskell :ensure t)
#+END_SRC

** PureScript

I started using PureScript for all my frontend works.

#+BEGIN_SRC emacs-lisp
  (add-hook 'purescript-mode-hook #'td/turn-off-evil-auto-indent)

  (use-package purescript-mode
    :ensure t
    :mode (("\\.purs\\'" . purescript-mode))
    :hook (purescript-mode . turn-on-purescript-indentation)
    :config
    (defun purescript-doc-current-info ()))

  (use-package psc-ide
    :ensure t
    :hook (purescript-mode . psc-ide-mode))
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :mode (("\\.go$" . go-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package company-go
    :ensure t
    :init (add-to-list 'company-backends 'company-go))

  (use-package go-eldoc
    :ensure t
    :init (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

** Swift

#+BEGIN_SRC emacs-lisp
  (use-package swift-mode
    :ensure t
    :mode (("\\.swift" . swift-mode)))
#+END_SRC

** Solidity

#+BEGIN_SRC emacs-lisp
  (use-package company-solidity
    :ensure t
    :defer t)

  (use-package solidity-mode
    :ensure t
    :mode (("\.sol$" . solidity-mode))
    :config
    (eval-and-compile
      (add-to-list 'company-backends 'company-solidity)))
#+END_SRC

** Misc

These are supports for other stuffs that I used:

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode))
    :hook (markdown-mode . whitespace-turn-off))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package nix-mode
    :ensure t
    :mode (("\\.nix$" . nix-mode))
    :config
    (exec-path-from-shell-copy-env "NIX_REMOTE"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode ("Dockerfile$" . dockerfile-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode
    :ensure t
    :mode (".*nginx.*\\.conf$" . nginx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode)
           ("\\.sls$" . yaml-mode)
           ("^master$" . yaml-mode)
           ("^roster$" . yaml-mode)))
#+END_SRC


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time loging

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :bind (("C-c o c" . org-occur-in-agenda-files))
    :config
    (setq org-directory "~/Desktop/"
          org-default-notes-file (expand-file-name "inbox.org" org-directory)
          org-agenda-files (list org-directory)
          org-agenda-skip-unavailable-files t
          org-hide-leading-stars t
          org-refile-targets (list '("~/Desktop/archive.org" . (:level . 1)))

          org-startup-with-inline-images t

          org-todo-keywords
          '((sequence "[ ](t)" "[-](p)" "[?](m)" "|" "[X](d)")
            (sequence "TODO(T)" "|" "DONE(D)")
            (sequence "NEXT(n)" "ACTIVE(a)" "WAITING(w)" "LATER(l)" "|" "CANCELLED(c)"))
          org-log-done 'time

          org-src-fontify-natively t)
    (add-hook 'org-mode-hook #'org-indent-mode))
#+END_SRC

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/cancelled)
- But don't have any todo items

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :config
    (setq org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-stuck-projects
          '("+project+LEVEL=1/-WAITING-DONE-CANCELLED" ("TODO" "WAITING") nil "")))
#+END_SRC

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

** Archive

I also use =org-board= to have an offline pin-board with org-mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-board
    :ensure t
    :defer t
    :bind-keymap ("C-c b" . org-board-keymap))
#+END_SRC

** Literate programming

Org Babel for literate programming and API documentation.

#+BEGIN_SRC emacs-lisp
  (use-package ob-http
    :defer t
    :ensure t)

  (use-package ob-core
    :defer t
    :config
    (setq org-confirm-babel-evaluate nil))

  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :hook (org-babel-after-execute . org-display-inline-images)
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t))))
#+END_SRC

** Spell checking

#+BEGIN_SRC emacs-lisp
  (when (executable-find "aspell")
    (use-package ispell
      :bind ("<f8>" . ispell-word)
      :init (setq-default ispell-program-name "aspell"
                          ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary")
                          ispell-skip-html t
                          ispell-silently-savep t
                          ispell-really-aspell t))

    (use-package flyspell
      :defer t
      :init (add-hook 'org-mode-hook 'flyspell-mode)
      ;; :config
      ;; (progn
      ;;   (require 'flyspell-ignore-faces)
      ;;   (put 'org-mode 'flyspell-mode-predicate 'td/flyspell-check-p))
      ))
#+END_SRC


* Look and feel

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        visible-bell nil
        ring-bell-function 'ignore
        scroll-preserve-screen-position t
        scroll-margin 8)
#+END_SRC

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+BEGIN_SRC emacs-lisp
  (setq-default
   fringes-outside-margins t
   default-frame-alist
   '((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     ;(font . "Monaco 14")
     ;(font . "Menlo 12")
     ;; (font . "Source Code Pro 14")
     (font . "Hasklig 14")
     ;(font . "Fira Code Retina 13")
     (top . 0) (left . 480)
     (width . 96) (height . 96)
     (vertical-scroll-bars . nil)
     (menu-bar-lines . 0)
     (tool-bar-lines . 0)))

  (blink-cursor-mode -1)
#+END_SRC

Enable ligatures, only available in railwaycat Mac port.

#+BEGIN_SRC emacs-lisp
  (mac-auto-operator-composition-mode)
#+END_SRC

Truncate lines:

#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(vertical-border ((t (:foreground "#000" :background "#000"))))
   ;;'(highlight ((t (:inherit region))))
   ;;'(sp-pair-overlay-face ((t (:inherit region))))
   ;;'(font-lock-string-face ((t (:slant normal))))
   ;;'(font-lock-comment-face ((t (:slant normal))))
   ;;'(font-lock-comment-delimiter-face
   ;;  ((t (:inherit font-lock-comment-face :foreground nil :slant normal))))

   '(line-number ((t (:height 120))))
   '(line-number-current-line ((t (:height 120 :bold nil))))
   ;;'(fringe ((t (:inherit nil))))
   ;;'(mode-line ((t (:box nil))))
   ;;'(mode-line-inactive ((t (:box nil))))

   '(indent-guide-face ((t (:inherit font-lock-comment-face))))
   '(nix-attribute-face ((t (:inherit font-lock-builtin-face))))
   '(web-mode-variable-name-face ((t (:inherit default))))

   '(diff-hl-insert ((t (:inherit nil :background nil :foreground "#81af34"))))
   '(diff-hl-delete ((t (:inherit nil :background nil :foreground "#ff0000"))))
   '(diff-hl-change ((t (:inherit nil :background nil :foreground "#deae3e"))))

   ;; tango-plus
   ;; '(font-lock-keyword-face ((t (:weight normal))))
   ;; '(font-lock-string-face ((t (:slant normal))))
   ;; '(font-lock-constant-face ((t (:slant normal))))

   ;; nord
   ;;'(haskell-operator-face ((t (:inherit font-lock-preprocessor-face :weight normal)))) ; nord10
   ;;'(highlight-numbers-number ((t (:inherit nil :foreground "#B48EAD")))) ; nord15
   ;; '(diff-hl-insert ((t (:inherit nil :background nil :foreground "#A3BE8C"))))
   ;; '(diff-hl-delete ((t (:inherit nil :background nil :foreground "#BF616A"))))
   ;; '(diff-hl-change ((t (:inherit nil :background nil :foreground "#EBCB8B"))))
   )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :ensure t
    :defer t
    :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package nord-theme
    :ensure t
    :init (load-theme 'nord t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :init
    (eval-and-compile
      (setq doom-themes-enable-italic nil
            doom-spacegrey-brighter-modeline t)
      (load-theme 'doom-tomorrow-night t))
    :hook (org-mode . doom-themes-org-config))
#+END_SRC

I also have an alternate light-theme for backup or use in
presentation, which is *base16-github* from [[https://github.com/belak/base16-emacs][base16-themes]] package.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package base16-theme
    :ensure t)
#+END_SRC

I also have very good experience with *Tango Plus*. Its philosophy of not
getting in the way is interesting.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tango-plus-theme
    :ensure t
    :init (load-theme 'tango-plus t))
#+END_SRC

Mode line

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :hook (after-init . sml/setup))
#+END_SRC

Show current function name in the mode line:

#+BEGIN_SRC emacs-lisp
  (which-function-mode t)
#+END_SRC

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (setq-default display-line-numbers-width 3)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'web-mode-hook #'display-line-numbers-mode)
#+END_SRC

The default line continuation indicator is too standout and distracting for me.

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b01000000
     #b10000000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
  (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :ensure t
    :commands (indent-guide-mode)
    :diminish indent-guide-mode
    :init
    (add-hook 'python-mode-hook #'indent-guide-mode)
    (add-hook 'yaml-mode-hook #'indent-guide-mode)
    (add-hook 'purescript-mode-hook #'indent-guide-mode)
    (add-hook 'haskell-mode-hook #'indent-guide-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    :config
    (eval-and-compile
      (setq rainbow-delimiters-max-face-count 1)

      (custom-theme-set-faces
       'user
       '(rainbow-delimiters-unmatched-face ((t (:inherit error :background "#f00")))))))
#+END_SRC

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer t
    :ensure t
    ;:hook (after-init . global-diff-hl-mode)
    :init
    (eval-and-compile
      (define-fringe-bitmap 'td/diff-hl-bmp [#b11110000] 1 8 '(top t))
      (defun td/diff-hl-bmp-fn (type pos) 'td/diff-hl-bmp)

      (setq diff-hl-draw-borders nil
            diff-hl-side 'right
            diff-hl-fringe-bmp-function #'td/diff-hl-bmp-fn)

      (defun diff-hl-overlay-modified (ov after-p beg end &optional len)
        "Markers disappear and reapear is kind of annoying to me.")))
#+END_SRC


* Misc

#+BEGIN_SRC emacs-lisp
  (use-package aria2
    :ensure t
    :defer t
    :config
    (setq aria2-add-evil-quirks t
          aria2-download-directory (expand-file-name "~/Downloads")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Google Chrome\" to reload active tab of window 1'"))

  (bind-key* "C-c b r" #'td/refresh-front-most-tab)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/cycle-themes ()
    (interactive)
    (let* ((current-theme (car custom-enabled-themes))
           (index (or (-elem-index current-theme (custom-available-themes)) 0))
           (next-theme (nth (+ 1 index) (custom-available-themes))))
      (disable-theme current-theme)
      (load-theme next-theme t)))

  (bind-key "C-c t n" #'td/cycle-themes)
#+END_SRC


* Init file generation

Where the magic happen!

#+BEGIN_SRC text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.emacs.d/init.el")) nil t)
  # End:
#+END_SRC
