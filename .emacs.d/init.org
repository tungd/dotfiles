#+title: Tung Dao
#+startup: overview
#+property: header-args :tangle yes :results silent

* Packages and initialization

  All the packages I used are from [[https://melpa.org][MELPA]]. However, I
  install them automatically with =use-package.el= instead of using =package.el=
  directly.

  #+BEGIN_SRC emacs-lisp
    (package-initialize)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  #+END_SRC

  Sometimes I write my own package, or download package from Emacs wiki; they
  are stored in the =~/.emacs.d/vendor= directory.

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
  #+END_SRC

  Use a dedicate custom file.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file 'noerror)
  #+END_SRC


* Defaults

  Personal information that some package use:

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Tung Dao"
          user-mail-address "me@tungdao.com"
          default-input-method 'vietnamese-telex)
    (defvar personal-keybindings nil)
  #+END_SRC

  Less verbose choice:

  #+BEGIN_SRC emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  =better-defaults= provide some sane, modern defaults:

  - clean minimal UI
  - search by regex by default
  - no unnecessary temporary files (I do keep backup files, but not auto-save
    and lock files)

  *NOTE*: I also set the delay right here since =better-defaults= loads
  =show-paren-mode=.

  #+BEGIN_SRC emacs-lisp
    (use-package better-defaults
      :ensure t
      :preface
      (setq-default show-paren-delay 0))

    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t))
          create-lockfiles nil)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package smex
      :ensure t
      :init (smex-initialize))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (savehist-mode t)
  #+END_SRC


* Navigation

** Projects

   I use =projectile= to switch between projects and between files in
   the same project. When possible I will use the functions provided
   by Emacs, however the project facilities built-in in recent version
   of Emacs but it is still bare bone.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :diminish projectile-mode
       :init (projectile-mode t)
       :config
       (setq projectile-globally-ignored-file-suffixes
             '("jpg" "png" "svg" "psd" "sketch" "afdesign"
               "pdf" "doc" "docx" "xls" "xlsx"
               "ttf" "otf" "woff"
               "rar" "zip" "min.js" "min.css" "map")))
   #+END_SRC

** Symbols

   For jumping to defined symbols (functions, classes, .etc), I use
   =dump-jump=. Mode specific support for this feature is at higher
   priority, when they fail =dump-jump= will be the fallback.

   The key bindings are:

   | Binding | Command                | Description    |
   |---------+------------------------+----------------|
   | =C-M-g= | =dump-jump-go=         | Jump to symbol |
   | =C-M-p= | =dump-jump-back=       | Back           |
   | =C-M-q= | =dump-jump-quick-look= | Quick look     |

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :ensure t
       :init (dumb-jump-mode t))
   #+END_SRC

** Ivy

   Ivy is a nice completion package, however the main reason I use it over =ido=
   is that I can make its popup appear at the top of the window.

   #+BEGIN_SRC emacs-lisp
     (ido-mode -1)

     (use-package ivy
       :init (ivy-mode t)
       :diminish ivy-mode
       :bind (("C-M-o" . ivy-switch-buffer))
       :config
       (progn
         (setq ivy-format-function 'ivy-format-function-arrow
               ivy-count-format ""
               ivy-use-virtual-buffers t
               ivy-height 16
               projectile-completion-system 'ivy)

         (require 'ivy-popup)))

     (use-package counsel
       :ensure t
       :bind (([remap find-file] . counsel-find-file)
              ([remap ido-find-file] . counsel-find-file)
              ([remap execute-extended-command] . counsel-M-x)
              ("C-M-'" . counsel-git)
              ("M-m" . counsel-M-x)
              ("C-c i" . counsel-imenu)))
   #+END_SRC


* General Editing

  Basic settings:

  #+BEGIN_SRC emacs-lisp
    (setq-default
     tab-width 2
     indent-tabs-mode nil
     reb-re-syntax 'string)
  #+END_SRC

  Editing utilities:

  #+BEGIN_SRC emacs-lisp
    (bind-key [remap delete-horizontal-space] #'cycle-spacing)

    (use-package crux
      :ensure t
      :commands (crux-sudo-edit
                 crux-switch-to-previous-buffer
                 crux-top-join-line
                 crux-cleanup-buffer-or-region
                 crux-kill-whole-line)
      :bind (("C-M-]" . crux-switch-to-previous-buffer)
             ("M-J" . crux-top-join-line)
             ("M-=" . crux-cleanup-buffer-or-region)
             ("C-M-k" . crux-kill-whole-line))
      :config
      (crux-with-region-or-buffer indent-region)
      (crux-with-region-or-buffer untabify)
      (crux-with-region-or-point-to-eol kill-ring-save))

    (defun td/kill-current-buffer ()
      (interactive)
      (kill-buffer))

    (bind-key "C-c C-k" #'td/kill-current-buffer)

    (use-package comment-dwim-2
      :ensure t
      :bind ([remap comment-dwim] . comment-dwim-2)
      :config (setq comment-style 'multi-line))
  #+END_SRC

  Automatically save buffers when focus out:

  #+BEGIN_SRC emacs-lisp
    (defun td/save-all-buffers ()
      (interactive)
      (save-some-buffers t))

    (add-hook 'focus-out-hook 'td/save-all-buffers)
  #+END_SRC

  Create directory for the file if not exists:

  #+BEGIN_SRC emacs-lisp
    (defun td/before-save-make-directories ()
      (let ((dir (file-name-directory buffer-file-name)))
        (when (and buffer-file-name (not (file-exists-p dir)))
          (make-directory dir t))))

    (add-hook 'before-save-hook #'td/before-save-make-directories)
  #+END_SRC

  Make the file executable if starting with "shebang":

  #+BEGIN_SRC emacs-lisp
    (defun td/after-save-auto-chmod ()
      (when (and (> (length (buffer-string)) 5)
                 (string-equal "#!" (buffer-substring-no-properties 1 4)))
        (shell-command
         (format "chmod u+x %s"
                 (shell-quote-argument (buffer-file-name))))))

    (add-hook 'after-save-hook #'td/after-save-auto-chmod)
  #+END_SRC

** Search and replace

   Anzu command names are confusing, at-cursor means initial string, while thing
   means boundary.

   #+BEGIN_SRC emacs-lisp
     (use-package anzu
       :ensure t
       :diminish anzu-mode
       :init (global-anzu-mode t)
       :bind (([remap query-replace] . anzu-query-replace)
              ;("C-c C-r" . anzu-query-replace-at-cursor)
              ("M-r" . anzu-replace-at-cursor-thing)
              ("C-M-r" . td/anzu-replace-at-cursor-thing-in-buffer))
       :config
       (progn
         (defun td/anzu-replace-at-cursor-thing-in-buffer ()
           "This does not actually query, but it's OK for me."
           (interactive)
           (let ((anzu-replace-at-cursor-thing 'buffer))
             (call-interactively 'anzu-query-replace-at-cursor-thing)))))
   #+END_SRC

   Also define "buffer-at-point" so that we can do query-replace in the whole
   buffer without having to jump to the beginning.

   #+BEGIN_SRC emacs-lisp
     (use-package thingatpt
       :init
       (progn
         (defun td/bounds-of-buffer-at-point ()
           (cons (point-min) (point-max)))

         (put 'buffer 'bounds-of-thing-at-point 'td/bounds-of-buffer-at-point)
         (put 'buffer 'beginning-op 'beginning-of-buffer)
         (put 'buffer 'end-op 'end-of-buffer)))
   #+END_SRC

   I also use ISearch for navigation. In such cases I want to put the cursor at
   the beginning of the match, not the end.

   #+BEGIN_SRC emacs-lisp
     (setq lazy-highlight-initial-delay 0)

     (defun td/isearch-exit-goto-match-beginning ()
       (interactive)
       (when (and isearch-forward isearch-other-end)
         (goto-char isearch-other-end)))

     (add-hook 'isearch-mode-end-hook #'td/isearch-exit-goto-match-beginning)
     (advice-add 'isearch-exit :after #'td/isearch-exit-goto-match-beginning)

     (use-package isearch+
       :ensure t)
   #+END_SRC

** Long lines

  Long lines are annoying. Auto wrap all texts at 80.

  #+BEGIN_SRC emacs-lisp
    (setq-default
     comment-auto-fill-only-comments t
     fill-column 80)

    (add-hook 'text-mode-hook #'turn-on-auto-fill)
    (add-hook 'prog-mode-hook #'turn-on-auto-fill)
  #+END_SRC

  Sometimes long lines are inevitable though, as I do have to manually edit
  exported SVG and minified JS :(. In those cases prevent them from making Emacs
  slow:

  #+BEGIN_SRC emacs-lisp
    (use-package so-long
      :commands so-long-enable
      :init (so-long-enable))
  #+END_SRC

** Whitespace

  Cleanup whitespaces automatically on save.

  #+BEGIN_SRC emacs-lisp
    (use-package whitespace
      :commands (whitespace-cleanup)
      :init (add-hook 'before-save-hook #'whitespace-cleanup))
  #+END_SRC

** Parenthesis

  Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
  use =smart-parens= to manage them. However the command name use words from an
  arcane language :(, so I put together a table of human-readable description of
  the commands. All key bindings are started with =M-s=.

  | Bindings  | Command                | Description                                         |
  |-----------+------------------------+-----------------------------------------------------|
  | =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
  | =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
  | =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
  | =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

  NOTE: This package is huge, I'm still learning it.

  #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t
      :diminish smartparens-mode
      :init (add-hook 'prog-mode-hook #'smartparens-mode)
      :bind (("M-s DEL" . sp-splice-sexp)
             ("M-S" . sp-rewrap-sexp)
             ("M-s <right>" . sp-slurp-hybrid-sexp)
             ("C-S-f" . sp-slurp-hybrid-sexp)
             ("M-s <left>" . sp-forward-barf-sexp)
             ("C-M-a" . sp-beginning-of-sexp)
             ("C-M-e" . sp-end-of-sexp)
             ("M-K" . sp-kill-sexp)
             ("M-]" . sp-select-next-thing))
      :functions (sp-pair)
      :config
      (set-face-attribute 'sp-pair-overlay-face nil :inherit 'region)
      (sp-pair "{" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "[" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "(" nil
               :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :ensure t
      :bind ("M--" . er/expand-region))

    (defun td/mark-line-dwim ()
      (interactive)
      (call-interactively #'beginning-of-line)
      (call-interactively #'set-mark-command))

    (bind-key "M-C-SPC" #'td/mark-line-dwim)
  #+END_SRC

** Undo

   By default Emacs doesn't even have redo!

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :init (global-undo-tree-mode t))
   #+END_SRC

** Snippets

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :diminish yas-minor-mode
       :commands yas-global-mode
       :init
       (progn
         (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
         (yas-global-mode t))
       :config
       (progn
         (setq yas-prompt-functions
               '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
               ;; Suppress excessive log messages
               yas-verbosity 1
               ;; I am a weird user, I use SPACE to expand my
               ;; snippets, this save me from triggering them accidentally.
               yas-expand-only-for-last-commands
               '(self-insert-command org-self-insert-command))

         (unbind-key "TAB" yas-minor-mode-map)
         (unbind-key "<tab>" yas-minor-mode-map)
         (bind-key "SPC" 'yas-expand yas-minor-mode-map)))
   #+END_SRC

** TODO Alignment

   #+BEGIN_SRC emacs-lisp
     (use-package align
       :defer t
       :bind ("C-c =" . align)
       :config
       (progn
         (add-to-list 'align-rules-list
                      '(js-object-props
                        (regexp . "\\(\\s-*\\):")
                        (modes . '(js-mode js2-mode))
                        (spacing . 0)))
         (add-to-list 'align-rules-list
                      '(scss-declaration
                        (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                        (group 1)
                        (modes . '(scss-mode))))))
   #+END_SRC

** Recent files

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :defer t
       :config
       (setq recentf-exclude
             '("/auto-install/" ".recentf" "/repos/" "/elpa/"
               "\\.mime-example" "\\.ido.last" "COMMIT_EDITMSG"
               ".gz" "~$" "/tmp/" "/ssh:" "/sudo:" "/scp:")))
   #+END_SRC


* Programming

** Auto completion

   I use auto completion sparingly. Mostly because many of the programing
   language support package use =company= for some of their functionalities. To
   be fair, I'd like these mode to support Emacs's standard
   =completion-at-point-functions= interface.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :diminish company-mode
       :bind ("M-/" . company-complete-common-or-cycle)
       :init (global-company-mode t)
       :config
       (progn
         (use-package company-buffer-line
           :commands (company-same-mode-buffer-lines)
           :bind ("C-x C-l" . company-same-mode-buffer-lines))

         (setq company-minimum-prefix-length 2
               company-require-match nil
               company-idle-delay nil
               company-tooltip-align-annotations t
               company-frontends
               '(company-pseudo-tooltip-unless-just-one-frontend
                 company-echo-metadata-frontend)
               company-backends
               '((company-dabbrev-code
                  :with
                  company-capf
                  company-yasnippet)))

         (bind-keys :map company-active-map
                    ("<tab>" . company-complete-common-or-cycle)
                    ("C-n" . company-select-next-or-abort)
                    ("C-p" . company-select-previous-or-abort))))
   #+END_SRC

** Error checking

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :commands flycheck-mode
       :init (add-hook 'prog-mode-hook #'flycheck-mode)
       :config
       (setq-default flycheck-disabled-checkers '(scss emacs-lisp-checkdoc)))
   #+END_SRC

** Version Control

   Git has won the version control war, everyone uses Git now. Emacs'
   built-in VC has great support for git but Magit is godsend.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :config
       (setq magit-display-buffer-function
             #'magit-display-buffer-fullframe-status-v1))
   #+END_SRC

** Compile

   I use =compile= not only for compilation but also as a generic method to run
   repetitive tasks. For example, I to run unit tests repeatedly, I first run
   =M-x compile= with the test commands. Subsequence =recompile= call will
   re-run the tests.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c m" #'recompile)
   #+END_SRC

** Web Development

   Not programming per-se. I use =web-mode= for all my templating-related
   editing, including PHP, since I rarely write PHP anymore.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :defer t
       :mode (("\\.html" . web-mode)
              ("\\.j2" . web-mode)
              ("\\.jinja2" . web-mode)
              ("\\.php" . web-mode)
              ("\\.tpl" . web-mode))
       :init (add-hook 'web-mode-hook #'emmet-mode)
       :config
       (progn
         (add-hook 'web-mode-hook #'turn-off-auto-fill)

         (setq web-mode-markup-indent-offset 2
               web-mode-css-indent-offset 2
               web-mode-code-indent-offset 2
               web-mode-script-padding 2
               web-mode-style-padding 2)))
   #+END_SRC

   Also, I can't live without Emmet.

   #+BEGIN_SRC emacs-lisp
     (use-package emmet-mode
       :ensure t
       :diminish emmet-mode
       :commands emmet-mode
       :init
       (progn
         (defun td/emmet-jsx-mode ()
           (interactive)
           (emmet-mode t)
           (setq-local emmet-expand-jsx-className? t))

         (add-hook 'sgml-mode-hook #'emmet-mode)
         (add-hook 'web-mode-hook #'emmet-mode)
         (add-hook 'css-mode-hook #'emmet-mode)
         (add-hook 'js2-jsx-mode-hook #'td/emmet-jsx-mode)
         (add-hook 'js-jsx-mode-hook #'td/emmet-jsx-mode))
       :config
       (progn
         (setq emmet-indentation 2
               emmet-preview-default nil
               emmet-insert-flash-time 0.1)

         (defun td/hide-emmet-preview-tooltip ()
           (overlay-put emmet-preview-output 'before-string nil))

         (advice-add 'emmet-preview
                     :after #'td/hide-emmet-preview-tooltip)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun td/format-html-attributes ()
       (interactive)
       (save-excursion
         (re-search-backward "<")
         (while (not (looking-at "[\n\r/]"))
           (re-search-forward "\s+[^=]+=")
           (goto-char (match-beginning 0))
           (newline-and-indent))))

     (bind-key "C-M-=" #'td/format-html-attributes)
   #+END_SRC

** CSS

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode
       :defer t
       :config
       (setq css-indent-offset 2))
   #+END_SRC

** JavaScript

   Like most people I used to use =js2-mode= for all my JavaScript editing,
   including JSX. Since I'm no longer write as much JavaScript, and I will use
   =es-lint= for syntax checking anyways, I think I'm going to give the built-in
   =js-mode= a try

   #+BEGIN_SRC emacs-lisp
     (use-package js
       :mode (("\\.js$" . js-mode)
              ("\\.jsx$" . js-jsx-mode)
              ("\\.json$" . js-mode)
              ("\\.eslintrc$" . js-mode))
       :config
       (setq js-indent-level 2
             js-indent-first-init 'dynamic
             js-switch-indent-offset 2
             js-enabled-frameworks '(javascript)))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     (use-package pyvenv
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package python
       :mode (("\\.py$" . python-mode)
              ("\\.waf$" . python-mode))
       :bind ([remap run-python] . td/run-python-with-project-root)
       :preface
       (progn
         (defun td/run-python-with-project-root ()
           (interactive)
           (let ((default-directory (projectile-project-root)))
             (call-interactively 'run-python)))))
   #+END_SRC

** TODO Elxir
** Haskell

   I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
   easy. There's also a catch-all IDE-like mode called =intero=, by the very
   same folk who runs =stack=.

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :ensure t
       :mode (("\\.hs$" . haskell-mode))
       ;; :config
       ;; (setq haskell-program-name "stack ghci")
       )

     (use-package intero
       :ensure t
       :diminish intero-mode
       :commands (intero-mode)
       ;; :init (add-hook 'haskell-mode-hook #'intero-mode)
       )
   #+END_SRC

** PureScript

   I started using PureScript for all my frontend works.

   #+BEGIN_SRC emacs-lisp
     (use-package purescript-mode
       :ensure t
       :mode (("\\.purs$" . purescript-mode))
       :config
       (progn
         (defun purescript-doc-current-info ())

         (add-hook 'purescript-mode-hook #'turn-on-purescript-indentation)

         (use-package psc-ide
           :ensure t
           :init (add-hook 'purescript-mode-hook #'psc-ide-mode))))
   #+END_SRC

** Misc

   These are supports for other stuffs that I used:

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode (("\\.md$" . markdown-mode)
              ("\\.markdown$" . markdown-mode)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode
       :ensure t
       :mode ("\\.nix$" . nix-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t
       :mode ("Dockerfile$" . dockerfile-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode
       :ensure t
       :mode ("\\.fish$" . fish-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package nginx-mode
       :ensure t
       :mode (".*nginx.*\\.conf$" . nginx-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode (("\\.yml$" . yaml-mode)
              ("\\.yaml$" . yaml-mode)
              ("\\.sls$" . yaml-mode)
              ("^master$" . yaml-mode)
              ("^roster$" . yaml-mode)))
   #+END_SRC


* Document and management

  I use Org for almost everything. Blogging, task management, API documentation,
  literate programming.

** Tracking and tasks management

   I tried many management tools: Wunderlist, Todoist, Google Calendar
   .etc. However all of them are missing something really crucial for me. For
   example Wunderlist has agenda overview, but lacks adding note to
   tasks. Evernote has execllent note support, but their project management is
   just barebone, not much than a todo list.

   Org on the other hand lacks notification and ubiquitous access. I'm looking
   for a solution though.

   Here's my basic Org setup:

   - A default =inbox.org= on Desktop for tasks capturing and project management
   - Nicer display with inline images
   - Enable GTD todo keyword sequence and time loging

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure t
       :config
       (setq org-directory "~/Desktop/"
             org-default-notes-file (expand-file-name "inbox.org" org-directory)
             org-agenda-files (list org-directory)
             org-agenda-skip-unavailable-files t
             org-hide-leading-stars t

             org-startup-with-inline-images t

             org-todo-keywords
             '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "|" "CANCELED(c@)" "DONE(d!)"))
             org-log-done 'time

             org-src-fontify-natively t))
   #+END_SRC

   Agenda overview and filtering. Org provides a bunch of quick overviews:

   | Binding                | Description                                   |
   |------------------------+-----------------------------------------------|
   | =C-c o a t=, =C-c o t= | List the TODO items                           |
   |------------------------+-----------------------------------------------|
   | =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
   |------------------------+-----------------------------------------------|
   | =C-c o a s=            | Search Org headers                            |

   Stuck projects are:

   - Top level outlines that have the tag =project=
   - Without holding state (waiting/done/cancelled)
   - But don't have any todo items

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :bind (("C-c o a" . org-agenda)
              ("C-c o t" . org-todo-list))
       :config
       (setq org-agenda-restore-windows-after-quit t
             org-agenda-window-setup 'current-window
             org-stuck-projects
             '("+project+LEVEL=1/-WAITING-DONE-CANCELLED" ("TODO" "WAITING") nil "")))
   #+END_SRC

** TODO Note taking

   As stated earlier, I practice GTD. Working projects and new stuffs go to
   =inbox.org= file. Old tasks are archived to =archive.org=. Here's my
   =org-capture= templates to dump stuffs to =inbox/note=

** TODO Org-refile for archive
** Literate programming

   Org Babel for literate programming and API documentation.

   #+BEGIN_SRC emacs-lisp
     (use-package ob-core
       :defer t
       :config
       (setq org-confirm-babel-evaluate nil))

     (use-package ob-http
       :ensure t
       :defer t
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (http . t))))
   #+END_SRC



** Blogging

   I use =org-publish= for blogging. The configuration is in a separate file
   here. This section only contains generic default settings for all of my
   publish project.

   #+BEGIN_SRC emacs-lisp
     ;; (use-package org-id
     ;;   :defer t
     ;;   :config
     ;;   (progn
     ;;     (defun td/org-export-anchor-id ())))
   #+END_SRC

** Stuffs to look at when I have time

*** TODO https://github.com/scallywag/org-board

*** TODO https://github.com/bard/org-dashboard

*** TODO https://github.com/abo-abo/org-download

*** TODO https://github.com/myuhe/org-gcal.el

*** TODO https://melpa.org/#/org-mac-link
*** TODO https://www.emacswiki.org/emacs/OutlineMode


* Look and feel

  I love eye candy <3. I put quite a lot of efforts to make Emacs look
  the way I liked.

  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen t
          visible-bell nil
          ring-bell-function 'ignore
          scroll-preserve-screen-position t
          scroll-margin 8)
  #+END_SRC

  Default window configuration: half-left of the screen, no scroll
  bars, no menu bars, no cursor blinking. And btw, nothing beats the
  classic Monaco, not even "Source Code Pro" by Adobe.

  #+BEGIN_SRC emacs-lisp
    (setq-default
     fringes-outside-margins t
     default-frame-alist
     '((font . "Source Code Pro 14")
       (top . 0) (left . 640)
       (width . 100) (height . 64)
       (vertical-scroll-bars . nil)
       (menu-bar-lines . 0)
       (tool-bar-lines . 0)
       (right-fringe . 0)))

    (blink-cursor-mode -1)
  #+END_SRC

  Truncate lines:

  #+BEGIN_SRC emacs-lisp
    (setq-default truncate-lines t)
  #+END_SRC

  Some preferences that I set for all the theme. Per documentation, the custom
  theme named =user= will always have the highest priority.

  #+BEGIN_SRC emacs-lisp
    (custom-theme-set-faces
     'user
     '(vertical-border ((t (:foreground "#000" :background "#000"))))

     '(linum ((t (:inherit font-lock-comment-face :height 110))))
     `(fringe ((t (:inherit font-lock-comment-face))))

     '(highlight ((t (:inherit region))))
     '(sp-pair-overlay-face ((t (:inherit region))))

     ;; tango-plus
     '(font-lock-keyword-face ((t (:weight normal))))
     '(font-lock-comment-face ((t (:slant normal))))
     '(font-lock-comment-delimiter-face ((t (:slant normal))))
     '(font-lock-string-face ((t (:slant normal))))
     '(font-lock-constant-face ((t (:slant normal))))

     ;; brin
     ;; '(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face :foreground nil))))
     ;; '(link ((t (:inherit font-lock-function-name-face :underline t))))
     ;; '(minibuffer-prompt ((t (:inherit font-lock-function-name-face))))
     )
  #+END_SRC

  My theme of choice is *Brin* from the exellent [[https://github.com/owainlewis/emacs-color-themes][sublime-themes]]
  collection.

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package sublime-themes
      :ensure t
      :init (load-theme 'brin t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package tango-plus-theme
      :ensure t
      :init (load-theme 'tango-plus t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package zerodark-theme
      :ensure t
      :init
      (progn
        (load-theme 'zerodark t)
        (zerodark-setup-modeline-format)))
  #+END_SRC

  I also have an alternate light-theme for backup or use in
  presentation, which is *base16-github* from [[https://github.com/belak/base16-emacs][base16-themes]] pacakge.

  #+BEGIN_SRC emacs-lisp
    (use-package base16-theme
      :ensure t)
  #+END_SRC

  Mode line

  #+BEGIN_SRC emacs-lisp
    (use-package smart-mode-line
      :ensure t
      :preface (setq-default sml/theme nil)
      :init (sml/setup))
  #+END_SRC

  Line and column numbers, which I find only helpful when tracking
  down compiler error :(.

  #+BEGIN_SRC emacs-lisp
    (column-number-mode t)

    (use-package nlinum
      :ensure t
      :init
      (when (display-graphic-p)
        (add-hook 'prog-mode-hook #'nlinum-mode))
      :config
      (setq nlinum-format " %3d ")
      (advice-add 'web-mode-fold-or-unfold :after 'nlinum--flush)
      (set-face-attribute 'fringe nil :background (face-background 'linum)))
  #+END_SRC

  The default line continuation indicator is too standout and distracting for me.

  #+BEGIN_SRC emacs-lisp
    (define-fringe-bitmap 'halftone
      [#b01000000
       #b10000000]
      nil nil '(top t))

    (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
    (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package indent-guide
      :ensure t
      :commands (indent-guide-mode)
      :init
      (add-hook 'python-mode-hook #'indent-guide-mode)
      (add-hook 'yaml-mode-hook #'indent-guide-mode)
      (add-hook 'purescript-mode-hook #'indent-guide-mode)
      (add-hook 'haskell-mode-hook #'indent-guide-mode))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :ensure t
      :commands rainbow-delimiters-mode
      :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
      :config
      (progn
        (setq rainbow-delimiters-max-face-count 1)

        (custom-theme-set-faces
         'user
         '(rainbow-delimiters-unmatched-face ((t (:inherit error :background "#f00")))))))
  #+END_SRC


* Init file generation

  Where the magic happen!

  #+BEGIN_SRC emacs-lisp
    (use-package async
      :ensure t
      :commands (async-start))

    (defun td/tangle-init ()
      (async-start
       (lambda ()
         (package-initialize)

         (require 'org)
         (org-babel-tangle-file
          (expand-file-name (concat user-emacs-directory "init.org"))
          (expand-file-name (concat user-emacs-directory "init.el"))
          "emacs-lisp")

         (require 'use-package)
         (require 'bind-key)

         (byte-compile-file
          (expand-file-name  (concat user-emacs-directory "init.el"))))
       'ignore))
  #+END_SRC

# Local Variables:
# after-save-hook: td/tangle-init
# End:
