#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

So, as an effort to improve the responsiveness, I'm going to reboot my Emacs
configuration. Hope it is better this time.

The idea is that I'm going to add things in, bit by bit, just enough to get it
going. This way I will be able to nail down the packages that cause issue, and
look for alternatives.

* Enable Lexical Binding

Make things a little bit faster. For context: https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding

#+begin_src emacs-lisp
  ;; -*- lexical-binding:t -*-
  (setenv
   "LIBRARY_PATH"
   (string-join
    '("/opt/local/lib/gcc14"
      "/opt/local/lib/gcc14/gcc/aarch64-apple-darwin24/14.2.0"
      "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib")
    ":"))
#+end_src


* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I install them automatically
with =use-package.el= instead of using =package.el= directly. Since Emacs 29.1,
=use-package.el= has been bundled with Emacs.

Also, Emacs 29.1 added the =package-vc-install= command, which is really handy as
quite a few of the packages I used are not available on MELPA yet.

#+begin_src emacs-lisp
  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    :custom
    (package-quickstart t))
#+end_src

#+begin_src emacs-lisp
  (setopt custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+end_src

#+begin_src emacs-lisp
  (use-package bind-key
    :functions (override-global-mode bind-key--remove)
    :hook (after-init . override-global-mode))
#+end_src

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+begin_src emacs-lisp
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "vendor/"))
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
  (add-to-list 'exec-path "/opt/local/bin")
  (add-to-list 'exec-path "~/Library/Python/3.12/bin/")
  (add-to-list 'exec-path "~/Library/pnpm")
  (add-to-list 'exec-path "~/.local/bin")
  (add-to-list 'exec-path "~/.opam/default/bin/")
  (add-to-list 'exec-path "~/.claude/local/")
  (setenv "PATH" (string-join exec-path ":"))
#+end_src


* Defaults

Personal information that some package use:

#+begin_src emacs-lisp
  (setopt user-full-name "Tung Dao"
          user-mail-address "me@tungdao.com"
          default-input-method "vietnamese-telex")
  (defvar personal-keybindings nil)
#+end_src

Less verbose choice:

#+begin_src emacs-lisp
  (setq use-short-answers t
        history-delete-duplicates t)
#+end_src

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+begin_src emacs-lisp
  (setopt auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil
        remote-file-name-inhibit-locks t
        remote-file-name-inhibit-auto-save-visited t)
#+end_src

Performance stuffs, I'm not sure how relevant these are, since I've moved to =nativecomp=.

#+begin_src emacs-lisp
  (setq-default
   bidi-display-reordering nil
   bidi-paragraph-direction 'left-to-right
   bidi-inhibit-bpa t)

  (setq read-process-output-max (* 16 1024 1024)
        inhibit-compacting-font-caches t)
#+end_src

#+begin_src emacs-lisp
  (savehist-mode t)
#+end_src

#+begin_src emacs-lisp
  (setopt echo-keystrokes 0.02)
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :hook (after-init . which-key-mode)
    :custom
    (which-key-show-early-on-C-h t)
    (which-key-idle-delay most-positive-fixnum)
    (which-key-idle-secondary-delay 1e-100))
#+end_src

#+begin_src emacs-lisp
  (setopt enable-recursive-minibuffers t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package desktop
    :hook ((after-init . desktop-save-mode)
           (after-init . desktop-read)))
#+end_src

#+begin_src emacs-lisp
  (use-package midnight
    :hook (after-init . midnight-mode)
    :config
    (add-hook 'midnight-hook #'td/trash-desktop-screenshots)
    (add-hook 'midnight-hook #'td/trash-stale-node-modules))
#+end_src

** Server

#+begin_src emacs-lisp
  (use-package server
    :hook (after-init . server-start))
#+end_src


** MacOS specific stuffs

#+begin_src emacs-lisp
  (if (boundp 'ns-command-modifier)
      (setopt ns-command-modifier 'meta))
  (if (boundp 'ns-option-modifier)
      (setopt ns-option-modifier 'super))
  (if (boundp 'ns-use-native-fullscreen)
      (setopt ns-use-native-fullscreen t))

  (setopt trash-directory "~/.Trash"
        delete-by-moving-to-trash t)

  (defun td/trash-desktop-screenshots ()
    "Move screenshot files from Desktop to trash."
    (interactive)
    (let ((desktop-dir (expand-file-name "~/Desktop/")))
      (when (file-directory-p desktop-dir)
        (dolist (file (directory-files desktop-dir t "^Screenshot.*\\.png$"))
          (when (file-regular-p file)
            (move-file-to-trash file)
            (message "Trashed: %s" file))))))

  (defun td/trash-stale-node-modules ()
    "Trash node_modules folders whose parent hasn't been touched in 7 days.
Expects structure: ~/Projects/<org>/<project>/node_modules"
    (interactive)
    (let ((projects-dir (expand-file-name "~/Projects/"))
          (stale-days 7))
      (when (file-directory-p projects-dir)
        (dolist (org-dir (directory-files projects-dir t "^[^.]"))
          (when (file-directory-p org-dir)
            (dolist (project-dir (directory-files org-dir t "^[^.]"))
              (when (file-directory-p project-dir)
                (let ((node-modules (expand-file-name "node_modules" project-dir)))
                  (when (and (file-directory-p node-modules)
                             (> (time-to-seconds
                                 (time-subtract (current-time)
                                                (file-attribute-modification-time
                                                 (file-attributes project-dir))))
                                (* stale-days 24 60 60)))
                    (move-file-to-trash node-modules)
                    (message "Trashed: %s" node-modules))))))))))
#+end_src


* Navigation

** File position

#+begin_src emacs-lisp
  (use-package saveplace
    :hook (after-init . save-place-mode))
#+end_src

** Projects

#+begin_src emacs-lisp
  (use-package files
    :custom
    (remote-file-name-access-timeout 5)
    (find-file-visit-truename t))
#+end_src

Emacs built-in =project.el= has gone a long way so I'm using that now. There are
still some missing features coming from =projectile=, but I can live with that.

#+begin_src emacs-lisp
  (use-package project
    :commands (project-find-file project-vc-dir project-current)
    :custom
    (project-file-history-behavior 'relativize))
#+end_src

#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :bind ("C-c s" . rg-menu))
#+end_src

** Workspace

Perspective.el is nice, especially the narrowed down buffer list, however
Burly's killer feature is that it can restores windows that are not pointing to
buffers, .ie Eshell.


** Symbols

Using =dumb-jump= with =xref= integration. Fast, no server needed, works well
with Claude for deeper code understanding.

Default key bindings is

| Binding   | Command                              | Description |
|-----------+--------------------------------------+-------------|
| =M-.=     | =xref-find-definitions=              |             |
| =C-M-p=   | =xref-find-definitions-other-window= |             |
| =C-M-g=   | =xref-pop-marker-stack=              |             |

#+begin_src emacs-lisp
  (use-package grep
    :custom
    (grep-command "rg -nS --no-heading ")
    (grep-use-null-device nil))

  (use-package xref
    :bind (("C-M-p" . xref-find-definitions-other-window)
           ("C-M-g" . xref-go-back))
    :hook ((xref-after-update . outline-minor-mode))
    :custom
    (xref-search-program 'ripgrep))

  (use-package dumb-jump
    :ensure t
    :init (add-hook 'xref-backend-functions 'dumb-jump-xref-activate))
#+end_src

** Mini-buffer

Shortcut key to go back to the home directory, works regardless of the
mini-buffer completion framework.

#+begin_src emacs-lisp :tangle no
  (use-package minibuffer
    :custom
    (minibuffer-visible-completions t)
    (completion-eager-update t)
    (completion-eager-display t)
    (completion-auto-help 'always)
    (completion-show-help nil)
    ;(completion-auto-select 'second-tab)
    ;(completion-auto-select nil)
    (completion-auto-select t)
    (completions-max-height 20)
    (completions-sort 'historical)
    (completions-format 'one-column)
    (completions-detailed t)
    (completions-group t))

  (bind-key "TAB" #'minibuffer-complete minibuffer-mode-map)

  (bind-key "C-p" #'minibuffer-previous-completion minibuffer-local-map)
  (bind-key "C-n" #'minibuffer-next-completion minibuffer-local-map)

  (bind-key "C-p" #'minibuffer-previous-completion completion-in-region-mode-map)
  (bind-key "C-n" #'minibuffer-next-completion completion-in-region-mode-map)
#+end_src

#+begin_src emacs-lisp
  (ido-mode -1)

  (use-package vertico
    :ensure t
    :custom
    (vertico-count 20)
    (vertico-cycle t)
    (vertico-resize t)
    :hook (after-init . vertico-mode)
    :config
    ;; Adapted from vertico-reverse
    (defun vertico-bottom--display-candidates (lines)
      "Display lines in bottom."
      (move-overlay vertico--candidates-ov (point-min) (point-min))
      (unless (eq vertico-resize t)
        (setq lines (nconc (make-list (max 0 (- vertico-count (length lines))) "\n") lines)))
      (let ((string (apply #'concat lines)))
        (add-face-text-property 0 (length string) 'default 'append string)
        (overlay-put vertico--candidates-ov 'before-string string)
        (overlay-put vertico--candidates-ov 'after-string nil))
      (vertico--resize-window (length lines)))

    (advice-add #'vertico--display-candidates :override #'vertico-bottom--display-candidates))

  (use-package prescient
    :ensure t
    :hook (after-init . prescient-persist-mode)
    :init
    (add-to-list 'completion-styles 'prescient)
    (setq completion-preview-sort-function #'prescient-completion-sort))

  (defun td/minibuffer-smart-tilde ()
    (interactive)
    (if (not (looking-back "/" 0))
        (call-interactively 'self-insert-command)
      (beginning-of-line)
      (kill-line)
      (insert "~/")))

  (bind-key "~" #'td/minibuffer-smart-tilde minibuffer-local-map)
  (bind-key "<s-backspace>" #'backward-kill-word minibuffer-local-map)
#+end_src

#+begin_src emacs-lisp
  (defun td/isearch-consult-ripgrep ()
    "Launch consult-ripgrep with current search term.
  Uses project root if in a project, otherwise current directory."
    (interactive)
    (let* ((search-term (if isearch-string
                            isearch-string
                          (thing-at-point 'symbol t)))
           (current-proj (project-current))
           (search-dir (if current-proj
                           (project-root current-proj)
                         default-directory)))
      (isearch-exit)
      (consult-ripgrep search-dir search-term)))

  (use-package consult
    :ensure t
    :bind (("C-M-l" . consult-line)
           ("C-M-j" . consult-buffer)
           ("M-g b" . consult-bookmark)
           ("M-g y" . consult-yank-from-kill-ring)
           ("M-g t" . consult-theme)
           ("M-g m" . consult-mode-command)
           ("M-g r" . consult-ripgrep)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap imenu] . consult-imenu)
           :map isearch-mode-map
           ("C-i" . td/isearch-consult-ripgrep))
    :custom
    (consult-narrow-key (kbd "<"))
    (consult-project-root-function #'vc-root-dir)
    (consult-preview-key nil)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))

  (use-package consult-flymake
    :bind ("M-g e" . consult-flymake))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package codex
    :commands (codex-start codex-command-menu codex-code-change)
    :bind* (("C-l x" . codex-start)
            ("C-l c" . codex-command-menu)
            :map codex-transcript-mode-map
            ("M-c" . magit-stash))
    :config
    (defun td/codex-notify ()
      (let* ((title "Codex")
             (body (format "Waiting for input in %s" (buffer-name)))
             (script (format "display notification %S with title %S sound name \"Funk\"" body title)))
        (make-process :name "codex-notify"
                      :buffer nil
                      :noquery t
                      :command (list "osascript" "-e" script)
                      :sentinel (lambda (_proc _event) nil))
        ;(message "[Codex] %s" body)
        ))
    (add-hook 'codex-waiting-hook #'td/codex-notify))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package claudecode
    :commands (claudecode-start claudecode-command-menu claudecode-code-change)
    :custom
    (claudecode-program "/Users/tung/.claude/local/claude")
    :bind* (("C-l x" . claudecode-start)
            ("C-l c" . claudecode-command-menu)))
#+end_src

#+begin_src emacs-lisp
  (use-package claude-code-ide
    :vc (:url "https://github.com/manzaltu/claude-code-ide.el" :rev :newest)
    :bind ("C-c C-'" . claude-code-ide-menu) ; Set your favorite keybinding
    :config
    (claude-code-ide-emacs-tools-setup)  ; Optionally enable Emacs MCP tools

    ;; Replace ediff with unified diff-mode for cleaner single-buffer diffs
    (defvar-local claude-code-ide--diff-info nil
      "Buffer-local storage for diff session info.")

    (defun claude-code-ide--unified-diff-accept ()
      "Accept the changes shown in this diff buffer."
      (interactive)
      (when-let* ((info claude-code-ide--diff-info)
                  (session (alist-get 'session info))
                  (tab-name (alist-get 'tab-name info))
                  (buffer-B (alist-get 'buffer-B info))
                  (new-content (with-current-buffer buffer-B (buffer-string))))
        (claude-code-ide-mcp-complete-deferred
         session "openDiff"
         (list `((type . "text") (text . "FILE_SAVED"))
               `((type . "text") (text . ,new-content)))
         tab-name)
        (claude-code-ide--unified-diff-cleanup info)))

    (defun claude-code-ide--unified-diff-reject ()
      "Reject the changes shown in this diff buffer."
      (interactive)
      (when-let* ((info claude-code-ide--diff-info)
                  (session (alist-get 'session info))
                  (tab-name (alist-get 'tab-name info)))
        (claude-code-ide-mcp-complete-deferred
         session "openDiff"
         (list `((type . "text") (text . "DIFF_REJECTED"))
               `((type . "text") (text . ,tab-name)))
         tab-name)
        (claude-code-ide--unified-diff-cleanup info)))

    (defun claude-code-ide--unified-diff-cleanup (info)
      "Clean up diff buffers from INFO."
      (let ((buffer-A (alist-get 'buffer-A info))
            (buffer-B (alist-get 'buffer-B info))
            (diff-buffer (alist-get 'diff-buffer info))
            (file-exists (alist-get 'file-exists info))
            (session (alist-get 'session info))
            (tab-name (alist-get 'tab-name info)))
        ;; Kill temp buffer-B
        (when (and buffer-B (buffer-live-p buffer-B))
          (kill-buffer buffer-B))
        ;; Kill buffer-A only if it was created for new file
        (when (and buffer-A (buffer-live-p buffer-A) (not file-exists))
          (kill-buffer buffer-A))
        ;; Kill diff buffer
        (when (and diff-buffer (buffer-live-p diff-buffer))
          (kill-buffer diff-buffer))
        ;; Remove from active diffs
        (when session
          (let ((active-diffs (claude-code-ide-mcp-session-active-diffs session)))
            (remhash tab-name active-diffs)))))

    (defvar claude-code-ide-unified-diff-mode-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "C-c C-c") #'claude-code-ide--unified-diff-accept)
        (define-key map (kbd "C-c C-k") #'claude-code-ide--unified-diff-reject)
        (define-key map (kbd "q") #'claude-code-ide--unified-diff-reject)
        map)
      "Keymap for claude-code-ide unified diff buffers.")

    (define-minor-mode claude-code-ide-unified-diff-mode
      "Minor mode for Claude Code unified diff buffers.
\\{claude-code-ide-unified-diff-mode-map}"
      :lighter " Claude-Diff"
      :keymap claude-code-ide-unified-diff-mode-map)

    (defun claude-code-ide--open-diff-unified (args)
      "Open diff using unified diff-mode instead of ediff.
ARGS contains the original arguments to openDiff handler."
      (let ((old-file-path (alist-get 'old_file_path args))
            (new-file-contents (alist-get 'new_file_contents args))
            (tab-name (alist-get 'tab_name args))
            session buffer-A buffer-B file-exists diff-buf)

        ;; Find session
        (setq session (or (claude-code-ide-mcp--find-session-for-file old-file-path)
                          (claude-code-ide-mcp--get-current-session)))
        (unless session
          (signal 'mcp-error '("No active MCP session found")))

        ;; Clean up existing diff with same tab-name
        (let ((active-diffs (claude-code-ide-mcp-session-active-diffs session)))
          (when-let ((existing (gethash tab-name active-diffs)))
            (claude-code-ide--unified-diff-cleanup existing)))

        ;; Create buffer-A (original)
        (setq file-exists (file-exists-p old-file-path))
        (if file-exists
            (setq buffer-A (find-file-noselect old-file-path))
          (setq buffer-A (generate-new-buffer
                          (format "*New: %s*" (file-name-nondirectory old-file-path))))
          (with-current-buffer buffer-A
            (setq buffer-file-name old-file-path)))

        ;; Create buffer-B (new content)
        (setq buffer-B (generate-new-buffer (format "*Proposed: %s*" tab-name)))
        (with-current-buffer buffer-B
          (insert new-file-contents)
          (let ((mode (assoc-default old-file-path auto-mode-alist 'string-match)))
            (when mode (ignore-errors (funcall mode)))))

        ;; Create unified diff
        (setq diff-buf (diff-buffers buffer-A buffer-B nil 'noasync))

        ;; Store info and set up diff buffer
        (let ((info `((session . ,session)
                      (tab-name . ,tab-name)
                      (buffer-A . ,buffer-A)
                      (buffer-B . ,buffer-B)
                      (diff-buffer . ,diff-buf)
                      (file-exists . ,file-exists)
                      (old-file-path . ,old-file-path))))

          ;; Store in active diffs
          (puthash tab-name info (claude-code-ide-mcp-session-active-diffs session))

          ;; Configure diff buffer
          (with-current-buffer diff-buf
            (setq claude-code-ide--diff-info info)
            (claude-code-ide-unified-diff-mode 1)
            (setq header-line-format
                  (substitute-command-keys
                   "Diff: \\[claude-code-ide--unified-diff-accept] accept, \\[claude-code-ide--unified-diff-reject] reject")))

          ;; Display diff buffer
          (pop-to-buffer diff-buf))

        ;; Return deferred response
        `((deferred . t)
          (unique-key . ,tab-name)
          (session . ,session))))

    (advice-add 'claude-code-ide-mcp-handle-open-diff
                :override #'claude-code-ide--open-diff-unified)

    :custom
    (claude-code-ide-use-side-window nil))
#+end_src

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 256)
    :config
    (add-to-list 'recentf-exclude "elpa/.*")
    (add-to-list 'recentf-exclude "__init__.py")
    (add-to-list 'recentf-exclude "_build/*")
    (add-to-list 'recentf-exclude "node_modules/.*"))
#+end_src

#+begin_src emacs-lisp
  (bind-key* "C-;" #'execute-extended-command)
  (global-set-key (kbd "C-l") ctl-x-map)
#+end_src


** Bookmark

#+begin_src emacs-lisp
  (use-package bookmark
    :custom
    (bookmark-save-flag 1))
#+end_src


* Window Management

Temporary "focus" on a buffer by maximizing it in the current frame.

#+begin_src emacs-lisp
  (defun td/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (bind-key* [remap delete-other-windows] #'td/toggle-maximize-buffer)
  (bind-key* "M-C-o" #'td/toggle-maximize-buffer)
  (bind-key* "M-o" #'other-window)
#+end_src

Buffer location customization

#+begin_src emacs-lisp
  (use-package window
    :custom
    (split-height-threshold nil)
    :config
    ;; (add-to-list 'display-buffer-alist
    ;;              '("^\\*codex:"
    ;;                (display-buffer-in-side-window)
    ;;                (side . right)
    ;;                (window-width . 0.32)))
    ;; (add-to-list 'display-buffer-alist
    ;;              '("^\\*claude:"
    ;;                (display-buffer-in-direction)
    ;;                (direction . right)
    ;;                (window-width . 85)))
    (add-to-list 'display-buffer-alist
                 '("\\*Warnings\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8)))
    (add-to-list 'display-buffer-alist
                 '("\\*Help\\*"
                   (display-buffer-reuse-window display-buffer-pop-up-window)
                   (inhibit-same-window . t)))
    (add-to-list 'display-buffer-alist
                 '("\\*Org-Babel Error Output\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8))))
#+end_src


* General Editing

#+begin_src emacs-lisp
  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package vundo :ensure t)
#+end_src

#+begin_src emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+end_src

#+begin_src emacs-lisp
  (use-package misc
    :custom
    (duplicate-line-final-position -1)
    :bind*
    ("C-c C-d" . duplicate-dwim))
#+end_src

#+begin_src emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward))
#+end_src

#+begin_src emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer)
    :custom
    (ibuffer-saved-filter-groups
     '(("default"
        ("Claude" (name . "^\\*claude:"))
        ("Org" (mode . org-mode))
        ("Dired" (mode . dired-mode))
        ("Special" (name . "^\\*.*\\*$")))))
    :hook (ibuffer-mode . (lambda () (ibuffer-switch-to-saved-filter-groups "default"))))
#+end_src

#+begin_src emacs-lisp
  (setopt kill-do-not-save-duplicates t)
#+end_src

Basic settings:

#+begin_src emacs-lisp
    (setq-default
     tab-width 2
     indent-tabs-mode nil
     reb-re-syntax 'string)
#+end_src

Editing utilities:

#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (;; There's a built-in `switch-to-prev-buffer', but it is less helpful
           ;; since it doesn't allow me to quickly switch between the most
           ;; recent buffers
           ("M-C-]" . crux-switch-to-previous-buffer)
           ("M-J" . join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c C-o" . crux-open-with))
    :config
    ;(crux-with-region-or-buffer indent-region)
    ;(crux-with-region-or-buffer untabify)
    ;(crux-with-region-or-point-to-eol kill-ring-save)
    (setopt kill-do-not-save-duplicates t))

  (bind-key* "C-x C-k" #'kill-current-buffer)
  (bind-key* "C-c r" #'rename-visited-file)
  (bind-key* [remap keyboard-quit] #'crux-keyboard-quit-dwim)
  (bind-key* [remap kill-line] #'crux-smart-kill-line)
  (bind-key* "s-n" #'next-buffer)
  (bind-key* "s-p" #'previous-buffer)
#+end_src

Make the file executable if starting with "shebang":

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Search and replace

#+begin_src emacs-lisp
  (use-package isearch
    :custom
    (isearch-wrap-pause 'no)
    (isearch-lazy-count t)
    (search-ring-max 256)
    (regexp-search-ring-max 200)
    (search-allow-motion t)
    (isearch-motion-changes-direction t)
    :bind
    (([remap isearch-forward] . isearch-forward-regexp)
     ([remap isearch-backward] . isearch-backward-regexp)))
#+end_src

#+begin_src emacs-lisp
  (use-package visual-replace
    :ensure t
    :bind (("M-r" . visual-replace)
           ([remap query-replace] . visual-replace)
           :map isearch-mode-map
           ("M-r" . visual-replace-from-isearch))
    :custom
    (visual-replace-default-to-full-scope t)
    (visual-replace-display-total t)
    (visual-replace-keep-initial-position t)
    :config
    (define-key visual-replace-mode-map (kbd "M-r")
                visual-replace-secondary-mode-map)
    (unbind-key [remap yank] visual-replace-mode-map))
#+end_src

#+begin_src emacs-lisp
  (use-package replace
    :bind (:map isearch-mode-map ("C-o" . isearch-occur))
    :config
    (add-to-list 'display-buffer-alist
                 '("\\*Occur\\*"
                   (display-buffer-reuse-mode-window display-buffer-below-selected)
                   (dedicated . t)
                   (post-command-select-window . t)
                   (window-height . 20))))
#+end_src

#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind (:map isearch-mode-map
                ("C-j" . avy-isearch))
    :bind* ("C-'" . avy-goto-char-timer)
    :custom
    (avy-background t)
    (avy-all-windows t))
#+end_src

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+begin_src emacs-lisp
  (use-package autorevert
    :hook (after-init . global-auto-revert-mode)
    :custom
    (auto-revert-avoid-polling t)
    (auto-revert-interval 5)
    (auto-revert-check-vc-info t))

  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+end_src

** Whitespace

Cleanup whitespaces automatically on save.

#+begin_src emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup)
    :config
    ;; (setopt whitespace-style (remove 'newline-mark whitespace-style))
    )
#+end_src

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with.

#+begin_src emacs-lisp
  (use-package paren
    :hook (after-init . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-context-when-offscreen 'overlay))

  (use-package elec-pair
    :hook (after-init . electric-pair-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package surround
    :ensure t
    :bind-keymap ("C-M-s" . surround-keymap))
#+end_src

#+begin_src emacs-lisp
  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)

  (use-package delsel
    :hook (after-init . delete-selection-mode))
#+end_src

** Snippets

I've since switched to =Tempel= instead of =Yasnippet=. With Copilot, the
suggestions is my snippet/template. Coupled with Eglot/LSP for
function/method-based templates, I rarely need a library of
snippets/templates. For the occasional needs that is specific to me/my workflow,
a more minimal template library like =Tempo=/=Tempel= is suffice.

I settled with =Tempel=, it polished some of the rough edges with =Tempo=, namely:

- Per-language/major-mode templates. =Tempo= does support this in the form of
  tags, however it requires some glue code, while =Tempel= has built-in support
- Temporary key map for moving between placeholders/poi/marks

Since the template definition is compatible between the 2, I can easily move to
=Tempo= in the future if it added support for the 2 points above.

#+begin_src emacs-lisp
  (use-package tempel
    :ensure t
    :hook (after-init . global-tempel-abbrev-mode)
    :bind (("M-+" . tempel-complete)
           ("M-*" . tempel-insert)))
#+end_src

Tempo integration code for future reference:

#+begin_src emacs-lisp :tangle no
  (defun td/tempo-space-dwim ()
    (interactive "*")
    (or (tempo-expand-if-complete) (insert " ")))

  (defun td/tempo-forward-mark-dwim ()
    (interactive)
    (or (tempo-forward-mark) (forward-paragraph)))

  (use-package tempo
    :functions (tempo-define-template tempo-expand-if-complete)
    :bind (("M-+" . tempo-complete-tag)
           ("SPC" . td/tempo-space-dwim)
           ("M-}" . td/tempo-forward-mark-dwim))
    :custom
    (tempo-insert-region t)
    :init
    (tempo-define-template tempo-expand-if-complete)))
#+end_src

** Alignment

#+begin_src emacs-lisp
  (use-package align
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode js-ts-mode tsx-ts-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode css-ts-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1))))
#+end_src

** Diff

#+begin_src emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-keep-variants nil)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally))
#+end_src


* Shell and remote

#+begin_src emacs-lisp
  (use-package envrc
    :ensure t
    :hook (after-init . envrc-global-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package comint
    :bind ("C-c C-l" . comint-clear-buffer)
    :custom
    (comint-terminfo-terminal "dumb-emacs-ansi"))
#+end_src

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :custom
    (vterm-shell "/bin/zsh -l"))
#+end_src

#+begin_src emacs-lisp
  (use-package detached
    :ensure t
    :hook (after-init . detached-init)
    :bind (;; Replace `async-shell-command' with `detached-shell-command'
           ([remap async-shell-command] . detached-shell-command)
           ;; Replace `compile' with `detached-compile'
           ;; ([remap compile] . detached-compile)
           ;; ([remap recompile] . detached-recompile)
           ;; Replace `project-compile' with `detached-project-compile'
           ;; ([remap project-compile] . detached-project-compile)
           ;; Replace built in completion of sessions with `consult'
           ([remap detached-open-session] . detached-consult-session))
    :custom ((detached-show-output-on-attach t)
             (detached-terminal-data-command system-type)))
#+end_src

** Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :custom
    (tramp-allow-unsafe-temporary-files t)
    (tramp-default-method "ssh")
    (tramp-use-scp-direct-remote-copying t)
    (tramp-copy-size-limit (* 1024 1024))
    (tramp-verbose 2)
    :config
    (add-to-list 'auth-sources (expand-file-name "authinfo.gpg" user-emacs-directory))
    (add-to-list 'auth-sources 'macos-keychain-generic t)
    (connection-local-set-profile-variables
     'remote-direct-async-process
     '((tramp-direct-async-process . t)))
    (connection-local-set-profiles
     '(:application tramp :protocol "scp")
     'remote-direct-async-process))
#+end_src

Some speedup for Tramp:

#+begin_src emacs-lisp
  (use-package vc
    :custom
    (vc-follow-symlinks t)
    (vc-handled-backends '(Git))
    (vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)" vc-ignore-dir-regexp tramp-file-name-regexp)))
#+end_src


* Programming

Native LSP support via =Eglot= since Emacs 29.1 (disabled - using dumb-jump + Claude instead)

#+begin_src emacs-lisp :tangle no
  (use-package eglot
    :hook ((js-ts-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure)
           (tsx-ts-mode . eglot-ensure)
           (go-ts-mode . eglot-ensure)
           (ocaml-ts-mode . eglot-ensure)
           (kotlin-ts-mode . eglot-ensure)
           (scala-ts-mode . eglot-ensure))
    :bind ("C-c M-a" . eglot-code-actions)
    :custom
    (eglot-auptoshutdown t)
    (eglot-ppprefer-plaintext t)
    (eglot-events-buffer-config '(:size 0))
    (eglot-connect-timeout 300)
    (eglot-ignored-server-capabilities '(:documentFormattingProvider
                                         :documentRangeFormattingProvider
                                         :documentOnTypeFormattingProvider
                                         :documentHighlightProvider))
    (eglot-extend-to-xref t)
    (eglot-code-action-indications '())
    :config
    (add-to-list 'eglot-server-programs '((neocaml-mode :language-id "ocaml") . ("ocamllsp")))
    (add-to-list 'eglot-server-programs '((tuareg-mode :language-id "ocaml") . ("ocamllsp")))
    (add-to-list 'eglot-server-programs '(ocaml-ts-mode "ocamllsp"))
    (add-to-list 'eglot-server-programs '((swift-ts-mode :language-id "swift") . ("/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/sourcekit-lsp")))
    (add-to-list 'eglot-server-programs '((swift-mode :language-id "swift") . ("/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/sourcekit-lsp")))
    (add-to-list 'eglot-server-programs '(kotlin-ts-mode "kotlin-language-server" "--stdio"))
    (add-to-list 'eglot-server-programs '((web-mode :language-id "typescriptreact") "typescript-language-server" "--stdio"))
    (add-to-list 'eglot-server-programs '(scala-ts-mode "metals")))
#+end_src

I'm experimenting with working purely with LLM and without LSP. It's not that I don't like LSP, it's just that I don't think it's efficient, especially in the era of LLM.

#+begin_src emacs-lisp :tangle no
  (use-package swift-ts-mode
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package eldoc
    :config
    (setopt eldoc-display-functions '(eldoc-display-in-buffer)))
#+end_src

Native Tree-sitter support since Emacs 29

The swift one is a bit tricky. The =parser.c= and =grammar.json= files are auto-generated, we need to download them from the CI build (https://github.com/alex-pinkus/tree-sitter-swift), then copy them to the source folder. After that we can use the following function call to build it:

#+begin_src emacs-lisp :tangle no
  (treesit--install-language-grammar-1
   "/Users/tung/.config/emacs/tree-sitter"
   'swift
   "https://github.com/alex-pinkus/tree-sitter-swift.git"
   "main"
   "/Users/tung/Projects/personal/tree-sitter-swift")
#+end_src

TODO: automating the entire process

#+begin_src emacs-lisp
  (defun td/treesit-mark-node (node)
    (goto-char (treesit-node-start node))
    (call-interactively #'set-mark-command)
    (goto-char (treesit-node-end node)))

  (defun td/tressit-expand-region ()
    "Poor man's expand-region, worked surprisingly well for me"
    (interactive)
    (if (treesit-language-at (point))
        (let ((start (if (region-active-p) (region-beginning) 1))
              (end (if (region-active-p) (region-end) 1))
              (node (if (region-active-p)
                        (treesit-node-parent
                         (treesit-node-on (region-beginning) (region-end)))
                      (treesit-node-at (point)))))
          (if (or (/= start (treesit-node-start node))
                  (/= end (treesit-node-end node)))
              (td/treesit-mark-node node)
            (forward-char)
            (td/tressit-expand-region)))
      (mark-sexp 1 t)))

  (bind-key "M--" #'td/tressit-expand-region)

  (use-package treesit
    :functions (treesit-node-on
                treesit-node-at
                treesit-node-parent
                treesit-node-start
                treesit-node-end
                treesit-node-prev-sibling)
    :config
    (add-to-list 'treesit-language-source-alist '(kotlin . ("https://github.com/fwcd/tree-sitter-kotlin.git")))
    (add-to-list 'treesit-language-source-alist '(protobuf . ("https://github.com/casouri/tree-sitter-module.git")))
    (add-to-list 'treesit-language-source-alist '(swift . ("https://github.com/alex-pinkus/tree-sitter-swift.git"))))

  (defun td/treesit-indent-debug (n p _bol)
    (message
     "treesit-indent-debug: %s %s %s"
     n p (treesit-node-prev-sibling n)))

  (defun td/treesit-tag-start (_n p _bol)
    (save-excursion
      (goto-char (treesit-node-start p))
      (search-forward "<")
      (- (point) 1)))

  (defun td/treesit-tag-sibling (n p bol)
    (when treesit--indent-verbose
      (td/treesit-indent-debug n p bol))
    (let* ((tag (treesit-parent-until
                 p
                 (rx (or "jsx_closing_element" "jsx_element" "jsx_self_closing_element"))))
           (prev (treesit-node-prev-sibling tag)))
      (when treesit--indent-verbose
        (message "tag: %s, prev: %s" tag prev))
      (cond
       ((treesit-node-match-p prev (rx "jsx_opening_element"))
        ;; This is the first child, need to check the parent tag
        (let ((parent-tag (treesit-parent-until tag "jsx_element")))
          (+ (td/treesit-tag-start tag parent-tag 0) typescript-ts-mode-indent-offset)))
       ((treesit-node-match-p tag (rx "jsx_closing_element"))
        (let ((parent-tag (treesit-parent-until tag "jsx_element")))
          (td/treesit-tag-start tag parent-tag 0)))
       (t (save-excursion
            (goto-char (treesit-node-start prev))
            (while (and (<= (point) (point-max))
                        (looking-at (rx (| whitespace control)) t))
              (forward-char))
            (point))))))

  (defvar td/tsx-additional-indent-rules
    '(((match nil "<") td/treesit-tag-sibling 0)
      ((parent-is "jsx_text") parent-bol 2)
      ((node-is "jsx_closing_element") td/treesit-tag-start 0)
      ((match "/" "jsx_self_closing_element") td/treesit-tag-start 0)
      ((match ">" "jsx_opening_element") td/treesit-tag-start 0)
      ((parent-is "jsx_opening_element") td/treesit-tag-start 2)
      ((parent-is "jsx_self_closing_element") td/treesit-tag-start 2)))

  (defun td/fix-tsx-indentation ()
    (setq-local
     treesit-simple-indent-rules
     (list (cons 'tsx (append td/tsx-additional-indent-rules (cdar (typescript-ts-mode--indent-rules 'tsx)))))))

  (use-package typescript-ts-mode
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode))
    ;:hook ((tsx-ts-mode . td/fix-tsx-indentation))
    )

  (use-package go-ts-mode
    :mode (("go.mod$" . go-mod-ts-mode)
           ("\\.go\\'" . go-ts-mode))
    :custom
    (go-ts-mode-indent-offset 2))

  (setopt
   major-mode-remap-alist
   '((js-mode . js-ts-mode)
     (typescript-mode . typescript-ts-mode)
     (json-mode . json-ts-mode)
     (css-mode . css-ts-mode)
     ;; (python-mode . python-ts-mode)
     ))
#+end_src

** Auto completion

I use auto completion sparingly.

#+begin_src emacs-lisp
  (use-package dabbrev
    :custom (dabbrev-case-fold-search nil)
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . completion-at-point)))

  (defun td/expand-lines ()
    (interactive)
    (let ((hippie-expand-try-functions-list
           '(try-expand-line)))
      (call-interactively 'hippie-expand)))

  (bind-key "C-x C-l" #'td/expand-lines)
#+end_src

#+begin_src emacs-lisp
  (use-package gptel-openai
    :functions gptel-make-openai)

  (use-package gptel-org)

  (use-package gptel
    :ensure t
    :bind ("C-l a" . gptel-menu)
    :hook (gptel-mode . visual-line-mode)
    :custom
    (gptel-model 'glm-4.7)
    (gptel-default-mode 'org-mode)
    :config
    (require 'gptel-zai)
    (gptel-zai-setup))
#+end_src

** Error checking

#+begin_src emacs-lisp
  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error)))
#+end_src

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x p v" . magit)
    :custom
    (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
    (magit-show-long-lines-warning nil)
    :config
    (remove-hook 'server-switch-hook 'magit-commit-diff)
    (remove-hook 'with-editor-filter-visit-hook 'magit-commit-diff))
#+end_src

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+begin_src emacs-lisp
  (use-package compile
    :bind ("C-c m" . recompile)
    :hook (compilation-filter . ansi-color-compilation-filter)
    :hook (compilation-mode . visual-line-mode)
    :custom
    (compilation-ask-about-save nil)
    (compilation-scroll-output t)
    :config
    (remove-hook 'compilation-mode-hook #'tramp-compile-disable-ssh-controlmaster-options))
#+end_src

** Code folding

#+begin_src emacs-lisp
  (use-package treesit-fold
    :ensure t
    :hook ((after-init . global-treesit-fold-mode)
           ;(after-init . global-treesit-fold-indicators-mode)
           (treesit-fold-mode . treesit-fold-line-comment-mode))
    :config
    (define-fringe-bitmap 'treesit-fold-indicators-fr-plus
      [#b01100000
       #b00110000
       #b00011000
       #b00001100
       #b00011000
       #b00110000
       #b01100000
       #b00000000])
    (define-fringe-bitmap 'treesit-fold-indicators-fr-minus-tail
      [#b00000000
       #b10000010
       #b11000110
       #b01101100
       #b00111000
       #b00010000
       #b00000000
       #b00000000])
    (define-fringe-bitmap 'treesit-fold-indicators-fr-center
      (vector #b00000000))
    (define-fringe-bitmap 'treesit-fold-indicators-fr-end-left
      (vector #b00000000)))
#+end_src

** Web Development

#+begin_src emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+end_src

#+begin_src emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook (mhtml-mode . emmet-mode)
    :bind ("C-M-<return>" . emmet-expand-line)
    :config
    (unbind-key "C-j" emmet-mode-keymap))
#+end_src

#+begin_src emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :mode ("\\.css\\'" . css-ts-mode)
    :custom
    (css-indent-offset 2))
#+end_src

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try.

#+begin_src emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . json-ts-mode))
    :mode (("\\.mjs$" . js-ts-mode))
    :custom
    (js-indent-level 2)
    (js-indent-first-init 'dynamic)
    (js-switch-indent-offset 2)
    (js-enabled-frameworks '(javascript)))
#+end_src

** Python

** OCaml

I'm a Python veteran. When I have the opportunity to, I tried to use
Haskell. Recently I have been looking into OCaml, it seems like a very good,
practical choice.

The following are the issues I have working in Python and Haskell, they are the
reason I'm considering OCaml as my main language. Hopefully I'll get a better
experience with OCaml. Besides the fact that OCaml is strongly-typed and can be
used for both the web and server, following are my bad experiences with either
Python or Haskell:

1. Python:
   - No good package manager: poetry used to be the silver bullet, combining
     =pyenv= and =pipenv=, while also fixing their issues. For what it's worth,
     Poetry is miles better than the previous solutions, yet it still suffers
     from problems that are unbearable for me.
   - The lack of types. That alone is a serious drawback for me. Sure I can add
     type annotations and use mypy, but unless libraries are also shipped with
     type definitions, those provides very limited guarantee, which defeats the
     purpose of having types in the first place.
   - Library breaking changes: cryptonite changed and broke my code producing
     APNS push packages. It can't be detected until it's shipped to production,
     so it's really bad.

   2. Haskell
      - Stack breaks.
      - The compiler is slow, and there's no good story regarding cross-compile. My
        guess is that the runtime is so sophisticated that it has to be linked to
        at least libc, hence making producing static binaries much harder.
      - Lack of production oriented library/framework. It's kind of like with
        Clojure, the libraries are there and they are excellent, but there is no
        standard bundle requiring a lot of wiring setting up a project. OCaml has Sihl.
      - I was told that OCaml is worse than Haskell regarding libraries, but in my
        experience that is not true. OCaml might have less libraries, but they are
        much more comprehensive and well-maintained. A lot of the libraries in the
        Haskell world seems to be a one-off experiment, or an one-time job then
        abandoned at best. (I'm talking about iCalendar, and there are many other cases).

#+begin_src emacs-lisp :tangle no
  (use-package neocaml
    :vc (:url "https://github.com/bbatsov/neocaml" :rev :newest)
    :custom
    (neocaml-repl-program-name "dune")
    (neocaml-repl-program-args '("utop" "." "--" "-short-paths")))

  (use-package utop
    :ensure t
    :custom
    (utop-command "dune utop . -- -emacs"))
#+end_src

** Java

** Kotlin

#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :ensure t
    :mode (("\\.kt\\'" . kotlin-ts-mode)
           ("\\.kts\\'" . kotlin-ts-mode)))
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t
    :mode (("\\.tf" . terraform-mode))
    :custom (terraform-format-on-save t))
#+end_src

** SQL

#+begin_src emacs-lisp
  (use-package sql
    :custom
    (sql-postgres-login-params
     '((user :default "postgres")
       (database :default "postgres")
       (server :default "localhost")
       (port :default 5432)))
    (sql-mysql-login-params
     '((user :default "root")
       (database :default "mysql")
       (server :default "root")
       (password :default "root")
       (port :default 3306))))
#+end_src

** Misc

These are supports for other stuffs that I used:

#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode (("\\.yaml$" . yaml-ts-mode)
           ("\\.yml$" . yaml-ts-mode))
    :hook ((yaml-ts-mode . display-line-numbers-mode)
           (yaml-ts-mode . visual-line-mode)))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package graphql-ts-mode
    :ensure t
    :mode ("\\.graphql\\'" "\\.gql\\'")
    :init
    (with-eval-after-load 'treesit
      (add-to-list 'treesit-language-source-alist
                   '(graphql "https://github.com/bkegley/tree-sitter-graphql"))))
#+end_src


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time logging

#+begin_src emacs-lisp
  (use-package ob-plantuml
    :custom
    (org-plantuml-jar-path "/opt/local/share/java/plantuml/plantuml.jar"))

  (defun td/org-electric-pair ()
    (setq-local
     electric-pair-inhibit-predicate
     `(lambda (c)
        (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))

  (use-package org
    :hook ((org-mode . org-indent-mode)
           (org-mode . visual-line-mode)
           (org-mode . td/org-electric-pair))
    :custom
    (org-directory "~/Documents/Journal")
    (org-default-notes-file (expand-file-name "inbox.org" org-directory))
    (org-agenda-files `(,org-directory))
    (org-agenda-skip-unavailable-files t)
    (org-hide-leading-stars t)
    (org-clock-persist 'history)
    ;; (org-refile-targets '(("~/Desktop/archive.org" . (:level . 1))))
    (org-startup-with-inline-images t)
    (org-startup-folded t)
    (org-todo-keywords
     '((sequence "TODO(t@)" "WAITING(w@)" "|" "DONE(d@/!)" "CANCELED(c@)")))
    (org-src-fontify-natively t)

    :config
    (require 'org-tempo)
    (org-clock-persistence-insinuate)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t)
       (ocaml . t)
       (plantuml . t)
       (python . t)
       (shell . t)
       (js . t)
       (kotlin . t)
       (sql . t)
       (sql-mode . t))))

  (use-package ob-sql-mode
    :ensure t)

  (use-package sql-clickhouse
    :defer t)
#+end_src

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/canceled)
- But don't have any todo items

#+begin_src emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :custom
    (org-agenda-restore-windows-after-quit t)
    (org-agenda-window-setup 'current-window)
    (org-stuck-projects
     '("+project+LEVEL=1/-WAITING-DONE-CANCELED" ("TODO" "WAITING") nil "")))
#+end_src

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

#+begin_src emacs-lisp
  (use-package org-capture
    :bind* (("C-c o c" . org-capture))
    :custom
    (org-capture-templates
     `(("t" "Inbox item" entry
        (file+headline "~/Desktop/inbox.org" "Inbox") nil)
       ("l" "TIL" entry
        (file+olp+datetree "~/Desktop/inbox.org" "TIL") nil
        :jump-to-captured t)
       ("b" "Blog" entry
        (file+olp+datetree "~/Desktop/inbox.org" "Blog") nil
        :jump-to-captured t))))
#+end_src

** Literate programming

Org Babel for literate programming and API documentation.

#+begin_src emacs-lisp
  (use-package ob-core
    :defer t
    :hook (org-babel-after-execute . org-display-inline-images)
    :custom
    (org-confirm-babel-evaluate nil))

  (use-package ob-http
    :defer t
    :ensure t
    :custom
    (ob-http:max-time 180)
    (ob-http:remove-cr t))

  (use-package ob-python
    :defer t
    :custom
    (org-babel-python-command "/opt/local/bin/python3.14"))
#+end_src

** Spell checking

#+begin_src emacs-lisp :tangle no
  (use-package ispell
    :bind ("s-i" . ispell-word)
    :custom
    (ispell-program-name "aspell")
    (ispell-extra-args
     '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary"))
    (ispell-skip-html t)
    (ispell-silently-savep t)
    (ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :hook (org-mode . flyspell-mode))
#+end_src


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+begin_src emacs-lisp
  (setopt inhibit-startup-screen t
          visible-bell nil
          ring-bell-function 'ignore
          scroll-preserve-screen-position t
          scroll-margin 5
          scroll-conservatively 0
          auto-window-vscroll nil)
#+end_src

I have a 2k display, and used to run a HiDPI hack for macOS. Recently I got a
new Mac and tired of running it. So here it goes:

#+begin_src emacs-lisp :tangle no
  (use-package adaptive-font-size-mode
    :hook (after-init . adaptive-font-size-mode))
#+end_src

I use mouse scroll a lot, and with the default key binding it would accidentally
change the text scale. I don't want this behavior, hence unbind the key here.

#+begin_src emacs-lisp
  (unbind-key "C-<mouse-5>")
  (unbind-key "C-<mouse-4>")
  (unbind-key "C-<wheel-down>")
  (unbind-key "C-<wheel-up>")
#+end_src

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+begin_src emacs-lisp
  (setopt
   default-frame-alist
   `((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     ;; (font . "Monaco 16")
     ;; (font . "Iosevka Fixed SS07 16")
     ;; (font . "Iosevka Mono 16")
     (font . "JetBrains Mono NL 15")
     ;; (font . "Fira Mono 16")
     ;; (font . "Ubuntu Mono 16")
     (tool-bar-lines . 0)
     (fullscreen . maximized)
     (mac-appearance . dark)
     (ns-appearance . dark)
     (vertical-scroll-bars . nil)))

  (blink-cursor-mode -1)
  (tool-bar-mode -1)

  (setq-default
   cursor-in-non-selected-windows nil
   ;line-spacing 0.1
   )

  (unless (display-graphic-p)
    (menu-bar-mode -1))

  (context-menu-mode)
#+end_src

Hide unnecessary long mode line mode list

#+begin_src emacs-lisp
  (setopt mode-line-collapse-minor-modes t)
#+end_src

#+begin_src emacs-lisp
  (use-package hl-line
    :hook ((prog-mode . hl-line-mode)
           (text-mode . hl-line-mode)))
#+end_src

Truncate lines:

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indentation
    :ensure t
    :hook ((python-mode . highlight-indentation-mode)
           (yaml-mode . highlight-indentation-mode)
           (yaml-ts-mode . highlight-indentation-mode))
    :custom
    (highlight-indentation-blank-lines t))
#+end_src

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+begin_src emacs-lisp
  (setq modus-themes-common-palette-overrides
        '(;; Make the main background a soft dark gray instead of pure black
          ;; (bg-main "#1e1e1e")
          ;; Make the "dim" background (used for line numbers/sidebar) slightly lighter
          ;; (bg-dim  "#282828")
          ;; Optional: Soften the white text so it's not "piercing"
          (fg-main "#cfcfcf"))
        modus-themes-italic-constructs t
        modus-themes-bold-constructs nil    ;; Bold text can sometimes "bleed" on 4K screens
        modus-themes-mixed-fonts nil          ;; Use variable pitch for docs/org-mode
        modus-themes-variable-pitch-ui nil)

  (load-theme 'modus-vivendi t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (load-theme 'modus-operandi t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package tango-plus-theme
    :ensure t
    :init (load-theme 'tango-plus t))
#+end_src

#+begin_src emacs-lisp :tangle no
 (use-package notink-theme
   :ensure t
   :init (load-theme 'notink t))
#+end_src

#+begin_src emacs-lisp :tangle no
 (use-package pache-dark-theme
   :ensure t
   :init (load-theme 'pache-dark t))
#+end_src

#+begin_src emacs-lisp :tangle no
  (load-theme 'td t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package amaranth-dark-theme
    :ensure t
    :init (load-theme 'amaranth-dark t))
#+end_src

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(font-lock-comment-face ((t :slant normal)))
   '(font-lock-comment-delimiter-face ((t :slant normal)))
   '(font-lock-string-face ((t :slant normal)))
   '(font-lock-constant-face ((t :slant normal)))

   '(line-number ((t :slant normal :foreground unspecified :inherit font-lock-comment-face)))
   '(line-number ((t :slant normal :background unspecified :foreground "#444" :inherit font-lock-comment-face)))
   '(line-number-current-line ((t :slant normal :weight normal :foreground "#fff")))
   '(fringe ((t :inherit line-number :background unspecified)))
   ;'(vertical-border ((t :foreground "#222")))

   ;'(mode-line-buffer-id ((t :foreground "orange")))
   ;'(cursor ((t :background "orange")))
   '(eglot-highlight-symbol-face ((t :weight normal)))
   '(eglot-code-action-indicator-face ((t :weight normal)))
   '(eglot-inlay-hint-face ((t :height 1.0 :inherit font-lock-comment-face)))
   )
#+end_src

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+begin_src emacs-lisp
  (column-number-mode t)
  (line-number-mode t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package display-line-numbers
    :hook ((prog-mode . display-line-numbers-mode)
           ;(org-mode . display-line-numbers-mode)
           (yaml-mode . display-line-numbers-mode)
           (conf-mode . display-line-numbers-mode))
    :custom
    (display-line-numbers-width-start 100))
#+end_src

The default line continuation indicator is too standout and distracting for me.

#+begin_src emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b10100000
     #b01010000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) '(nil halftone))
  (setcdr (assq 'truncation fringe-indicator-alist) '(nil halftone))
#+end_src

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+begin_src emacs-lisp
  (defun td/diff-hl-fringe-bmp (_type _pos) 'halftone)

  (defun td/diff-hl-overlay-modified (_ov _after-p _beg _end &optional _len)
    "No-op. Markers disappear and reapear is annoying to me.")

  (use-package diff-hl
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :custom
    (diff-hl-draw-borders nil)
    (diff-hl-fringe-bmp-function #'td/diff-hl-fringe-bmp)
    (diff-hl-disable-on-remote t)
    :config
    (custom-theme-set-faces
     'user
     '(diff-hl-insert ((t (:inherit nil :background unspecified :foreground "#81af34"))))
     '(diff-hl-delete ((t (:inherit nil :background unspecified :foreground "#ff0000"))))
     '(diff-hl-change ((t (:inherit nil :background unspecified :foreground "#deae3e")))))

    (advice-add 'diff-hl-overlay-modified :override #'td/diff-hl-overlay-modified))
#+end_src


* Misc

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    (dired-listing-switches "-lah")
    (dired-auto-revert-buffer t)
    (dired-kill-when-opening-new-dired-buffer t))
#+end_src

#+begin_src emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Firefox\" to reload active tab of window 1'"))

  (bind-key* "C-M-r" #'td/refresh-front-most-tab)
#+end_src

#+begin_src emacs-lisp
  (use-package eat
    :ensure t)

  (setq use-default-font-for-symbols nil)
  (set-fontset-font t 'symbol "Menlo" nil 'prepend)
  (set-fontset-font t 'emoji "Menlo" nil 'prepend)
#+end_src


* Ideas

** Aphelia

https://github.com/radian-software/apheleia?tab=readme-ov-file

This seems really cool

** https://github.com/daedsidog/evedel
** Emacs cron job to watch github build of any of the opening project

#+begin_src emacs-lisp
  (use-package notmuch
    :ensure t
    :defer t
    :config
    ;; 1. Point to the MacPorts binary explicitly (avoids PATH issues)
    (setq notmuch-command "~/.local/bin/notmuch")

    ;; 2. Performance: asynchronous search to avoid blocking Emacs
    (setq notmuch-search-oldest-first nil)

    ;; 3. Theme Integration: notmuch usually works great with modus-vivendi-tinted,
    ;;    but you can force specific faces if needed.
    ;;    (setq notmuch-search-line-faces ...) ;; Usually not needed with Modus.

    ;; 4. "The Sync Command"
    ;;    This runs mbsync, then indexes with notmuch, then refreshes the buffer.
    (defun my/notmuch-sync ()
      "Sync email with mbsync, index with notmuch, and refresh the buffer."
      (interactive)
      (message "Syncing mail...")
      ;; Run mbsync and notmuch new in the background
      (start-process-shell-command
       "notmuch-sync"
       "*notmuch-sync*"
       ;; Combine commands: fetch -> index
       "mbsync -a && notmuch new")

      ;; Set a sentinel to refresh the buffer once the process finishes
      (set-process-sentinel
       (get-process "notmuch-sync")
       (lambda (proc event)
         (when (string= event "finished\n")
           (message "Mail sync completed.")
           ;; Refresh the current notmuch buffer if it's open
           (when (and (eq major-mode 'notmuch-search-mode)
                      (get-buffer-window (current-buffer)))
             (notmuch-refresh-this-buffer))))))

    ;; Keybinding for sync (e.g., 'S' in search mode)
    (define-key notmuch-search-mode-map "S" 'my/notmuch-sync)
    (define-key notmuch-hello-mode-map "S" 'my/notmuch-sync)

    (defun my/find-first-html-part (parts)
      "Recursively search for a text/html part in a list of parts."
      (cl-loop for part in parts
               if (string= (plist-get part :content-type) "text/html")
               return part
               else if (string= (plist-get part :content-type) "multipart/alternative")
               return (my/find-first-html-part (plist-get part :content))
               else if (string= (plist-get part :content-type) "multipart/related")
               return (my/find-first-html-part (plist-get part :content))
               else if (string= (plist-get part :content-type) "multipart/mixed")
               return (my/find-first-html-part (plist-get part :content))))

    (defun my/notmuch-show-view-html-xwidget ()
      "Find the HTML part, wrap it with a UTF-8 header, render in xwidget-webkit."
      (interactive)
      (let* ((msg (notmuch-show-get-message-properties))
             (body (plist-get msg :body))
             (html-part (my/find-first-html-part body)))

        (if html-part
            (let ((coding-system-for-write 'utf-8)
                  (file (make-temp-file "notmuch-xwidget-" nil ".html")))

              ;; Fetch the content (notmuch usually handles QP/Base64 decoding automatically)
              (let ((content (notmuch-get-bodypart-text msg html-part notmuch-show-process-crypto)))

                (with-temp-file file
                  ;; 1. Insert a proper HTML doctype and charset meta tag
                  (insert "<!DOCTYPE html>\n")
                  (insert "<html>\n<head>\n")
                  (insert "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n")
                  ;; Optional: Add viewport meta for better scaling
                  (insert "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n")
                  (insert "</head>\n<body>\n")

                  ;; 2. Insert the actual email body
                  (insert content)

                  ;; 3. Close tags
                  (insert "\n</body>\n</html>"))

                (xwidget-webkit-browse-url (concat "file://" file))
                (delete-other-windows)
                (message "Opened HTML view.")))
          (message "No HTML part found."))))

    ;; Keybinding: Press 'H' in the thread view to open the graphical view
    (define-key notmuch-show-mode-map "H" 'my/notmuch-show-view-html-xwidget))
#+end_src

* Init file generation

Where the magic happen!

#+begin_src text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.config/emacs/init.el")) nil t)
  # End:
#+end_src
