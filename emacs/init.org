#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

So, as an effort to improve the responsiveness, I'm going to reboot my Emacs
configuration. Hope it is better this time.

The idea is that I'm going to add things in, bit by bit, just enough to get it
going. This way I will be able to nail down the packages that cause issue, and
look for alternatives.

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I install them automatically
with =use-package.el= instead of using =package.el= directly. Since Emacs 29.1,
=use-package.el= has been bundled with Emacs.

Also, Emacs 29.1 added the =package-vc-install= command, which is really handy as
quite a few of the packages I used are not available on MELPA yet.

#+begin_src emacs-lisp
  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    :custom
    (package-quickstart t))
#+end_src

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+end_src

#+begin_src emacs-lisp
  (use-package bind-key
    :functions (override-global-mode bind-key--remove)
    :hook (after-init . override-global-mode))
#+end_src

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+begin_src emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+end_src


* Defaults

Personal information that some package use:

#+begin_src emacs-lisp
  (setq user-full-name "Tung Dao"
        user-mail-address "me@tungdao.com"
        default-input-method 'vietnamese-telex)
  (defvar personal-keybindings nil)
#+end_src

Less verbose choice:

#+begin_src emacs-lisp
  (setq use-short-answers t)
#+end_src

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil
        remote-file-name-inhibit-locks t)
#+end_src

Performance stuffs, I'm not sure how relevant these are, since I've moved to =nativecomp=.

#+begin_src emacs-lisp
  (setq-default
   bidi-display-reordering nil
   bidi-paragraph-direction 'left-to-right
   bidi-inhibit-bpa t)

  (setq read-process-output-max (* 16 1024 1024)
        inhibit-compacting-font-caches t)
#+end_src

#+begin_src emacs-lisp
  (savehist-mode t)
#+end_src

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.02)
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :hook (after-init . which-key-mode)
    :config
    (setq which-key-show-early-on-C-h t)
    (setq which-key-idle-delay most-positive-fixnum)
    (setq which-key-idle-secondary-delay 1e-100))
#+end_src

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

** Server

#+begin_src emacs-lisp
  (use-package server
    :hook (after-init . server-start))
#+end_src


** MacOS specific stuffs

#+begin_src emacs-lisp
  (if (boundp 'ns-command-modifier)
      (setq ns-command-modifier 'meta))
  (if (boundp 'ns-option-modifier)
      (setq ns-option-modifier 'super))
  (if (boundp 'ns-use-native-fullscreen)
      (setq ns-use-native-fullscreen t))

    (setq trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+end_src


* Navigation

** File position

#+begin_src emacs-lisp
(use-package saveplace
  :hook (after-init . save-place-mode))
#+end_src

** Projects

Emacs built-in =project.el= has gone a long way so I'm using that now. There are
still some missing features coming from =projectile=, but I can live with that.

#+begin_src emacs-lisp
  (use-package project
    :commands (project-find-file project-vc-dir project-current))
#+end_src

** Workspace

Perspective.el is nice, especially the narrowed down buffer list, however
Burly's killer feature is that it can restores windows that are not pointing to
buffers, .ie Eshell.

#+begin_src emacs-lisp :tangle no
  (use-package perspective
    :ensure t
    :functions (persp-mode)
    :hook
    ((after-init . persp-mode)
     (kill-emacs . persp-state-save))
    :custom
    (persp-mode-prefix-key (kbd "C-c C-p"))
    (persp-state-default-file (expand-file-name "persp-auto-save" user-emacs-directory))
    (persp-modestring-short t)
    :config
    (with-eval-after-load 'consult
      ;(consult-customize consult--source-buffer :hidden t :default nil)
      (add-to-list 'consult-buffer-sources persp-consult-source)))
#+end_src

#+begin_src emacs-lisp
  (use-package burly
    :ensure t
    :custom
    (burly-bookmark-prefix "Project: "))
#+end_src

** Symbols

I used to use =dumb-jumb=, but LSP has gotten good enough and it supported all
of the languages that I use, so now I use the built-in =xref= and rely on LSP's
=xref= integration.

Default key bindings is

| Binding   | Command                              | Description |
|-----------+--------------------------------------+-------------|
| =M-.=     | =xref-find-definitions=              |             |
| =C-M-p=   | =xref-find-definitions-other-window= |             |
| =C-M-g=   | =xref-pop-marker-stack=              |             |

#+begin_src emacs-lisp
  (use-package xref
    :bind (("C-M-p" . xref-find-definitions-other-window)
           ("C-M-g" . xref-go-back))
    :hook ((xref-after-update . outline-minor-mode)))

  (bind-key* "C-M-." #'xref-find-definitions)
#+end_src

** Mini-buffer

Shortcut key to go back to the home directory, works regardless of the
mini-buffer completion framework.

#+begin_src emacs-lisp
  (ido-mode -1)

  (defun td/minibuffer-smart-tilde ()
    (interactive)
    (if (not (looking-back "/" 0))
        (call-interactively 'self-insert-command)
      (beginning-of-line)
      (kill-line)
      (insert "~/")))

  (bind-key "~" #'td/minibuffer-smart-tilde minibuffer-local-map)
  (bind-key "<s-backspace>" #'backward-kill-word minibuffer-local-map)
#+end_src

Vertico is the next in line for vertical completion.

#+begin_src emacs-lisp
 (use-package vertico
   :ensure t
   :hook (after-init . vertico-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-M-l" . consult-line)
           ("C-M-j" . consult-buffer)
           ("M-g b" . consult-bookmark)
           ("M-g y" . consult-yank-from-kill-ring)
           ("M-g t" . consult-theme)
           ("M-g m" . consult-mode-command)
           ("M-g r" . consult-ripgrep)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap imenu] . consult-imenu))
    :custom
    (consult-narrow-key (kbd "<"))
    (consult-project-root-function #'vc-root-dir)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))

  (use-package consult-flymake
    :bind ("M-g e" . consult-flymake))
#+end_src

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 128)
    :config
    (add-to-list 'recentf-exclude "elpa/.*")
    (add-to-list 'recentf-exclude "__init__.py")
    (add-to-list 'recentf-exclude "_build/*")
    (add-to-list 'recentf-exclude "node_modules/.*"))
#+end_src

#+begin_src emacs-lisp
  (bind-key* "M-m" #'execute-extended-command)
#+end_src

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Bookmark

#+begin_src emacs-lisp
  (use-package bookmark
    :custom
    (bookmark-save-flag 1))
#+end_src


* Window Management

Temporary "focus" on a buffer by maximizing it in the current frame.

#+begin_src emacs-lisp
  (defun td/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (bind-key* [remap delete-other-windows] #'td/toggle-maximize-buffer)
  (bind-key* "M-C-o" #'td/toggle-maximize-buffer)
  (bind-key* "M-o" #'other-window)
#+end_src

Buffer location customization

#+begin_src emacs-lisp
  ;(tab-bar-mode t)

  (use-package window
    :custom
    (window-min-height 1)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\*compilation\\*" (display-buffer-reuse-window display-buffer-below-selected)
                   (inhibit-same-window . t)
                   (window-height . 16)))
    (add-to-list 'display-buffer-alist
                 '("\\*Warnings\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8)))
    (add-to-list 'display-buffer-alist
                 '("\\*Help\\*"
                   (display-buffer-reuse-window display-buffer-pop-up-window)
                   (inhibit-same-window . t)))
    (add-to-list 'display-buffer-alist
                 '("\\*Org-Babel Error Output\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8)))
    ;; (add-to-list 'display-buffer-alist
    ;;              `(,(rx (| "inbox.org" "*Org Agenda*" "init.org"))
    ;;                (display-buffer-in-tab display-buffer-full-frame)
    ;;                (ignore-current-tab . t)
    ;;                (tab-name . "ðŸš€ Org")
    ;;                (tab-group . "Org")))
    ;; (add-to-list 'display-buffer-alist
    ;;              `("\\*Org Src" display-buffer-full-frame))
    ;; (add-to-list 'display-buffer-alist
    ;;              `(,(rx (| "README.org" "WORKBOOK.org" "NOTES.org")) display-buffer-full-frame))
    )
#+end_src


* General Editing

#+begin_src emacs-lisp
  (use-package undo-fu-session
    :ensure t
    :hook (after-init . undo-fu-session-global-mode)
    :custom
    (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'")))

  (use-package vundo :ensure t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package evil
    :ensure t
    :hook (after-init . evil-mode)
    :custom
    (evil-cross-lines t)
    (evil-ex-substitute-global t)
    (evil-undo-system 'undo-redo))

  (use-package evil-surround
    :ensure t
    :hook (evil-mode . global-evil-surround-mode))
#+end_src

#+begin_src emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+end_src

#+begin_src emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward))
#+end_src

#+begin_src emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer))
#+end_src

#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

Basic settings:

#+begin_src emacs-lisp
  (setq-default
   tab-width 2
   indent-tabs-mode nil
   require-final-newline t
   reb-re-syntax 'string)
#+end_src

Editing utilities:

#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :hook (after-init . crux-reopen-as-root-mode)
    :bind (;; There's a built-in `switch-to-prev-buffer', but it is less helpful
           ;; since it is not allowing me to quickly switch between the most
           ;; recent buffers
           ("M-C-]" . crux-switch-to-previous-buffer)
           ("M-J" . crux-top-join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c C-o" . crux-open-with)
           ([remap kill-line] . crux-smart-kill-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save)
    (setq kill-do-not-save-duplicates t))

  (bind-key* "C-x C-k" #'kill-this-buffer)
  (bind-key* "C-c r" #'rename-visited-file)
  (bind-key* "s-n" #'next-buffer)
  (bind-key* "s-p" #'previous-buffer)
#+end_src

Create directory for the file if not exists:

#+begin_src emacs-lisp
  (defun td/make-new-directories ()
    (let ((dir (file-name-directory buffer-file-name)))
      (when (and buffer-file-name (not (file-exists-p dir)))
        (make-directory dir t))))

  (add-to-list 'find-file-not-found-functions #'td/make-new-directories)
#+end_src

Make the file executable if starting with "shebang":

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Search and replace

#+begin_src emacs-lisp
  (use-package isearch
    :defer t
    :custom
    (isearch-wrap-pause 'no)
    (isearch-lazy-count t)
    (search-ring-max 256)
    (regexp-search-ring-max 200)
    :bind
    ([remap isearch-forward] . isearch-forward-regexp)
    ([remap isearch-backward] . isearch-backward-regexp))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package isearch-mb
    :ensure t
    :hook (after-init . isearch-mb-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package visual-regexp
    :ensure t
    :bind (("M-r" . vr/query-replace)
           ([remap query-replace] . vr/query-replace)
           ("C-M-r" . vr/mc-mark)))
#+end_src

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+begin_src emacs-lisp
  (use-package autorevert
    :hook (after-init . global-auto-revert-mode))

  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+end_src

** Whitespace

Cleanup whitespaces automatically on save.

#+begin_src emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup))
#+end_src

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
use =smart-parens= to manage them. However the command name use words from an
arcane language :(, so I put together a table of human-readable description of
the commands. All key bindings are started with =M-s=.

| Bindings  | Command                | Description                                         |
|-----------+------------------------+-----------------------------------------------------|
| =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
| =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
| =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
| =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

NOTE: This package is huge, I'm still learning it.

#+begin_src emacs-lisp :tangle no
  (use-package smartparens
    :ensure t
    :hook ((prog-mode . smartparens-mode))
    :bind (("M-s DEL" . sp-splice-sexp)
           ("M-S" . sp-rewrap-sexp)
           ("M-s <right>" . sp-slurp-hybrid-sexp)
           ("C-S-f" . sp-slurp-hybrid-sexp)
           ("M-s <left>" . sp-forward-barf-sexp)
           ("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("M-K" . sp-kill-sexp)
           ("M-]" . sp-select-next-thing))
    :config
    (sp-pair "{" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
#+end_src

#+begin_src emacs-lisp
  (use-package paren
    :hook (after-init . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-context-when-offscreen 'overlay))

  (use-package elec-pair
    :hook (after-init . electric-pair-mode))
#+end_src

#+begin_src emacs-lisp
  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)

  (use-package delsel
    :hook (after-init . delete-selection-mode))
#+end_src

** Snippets

I've since switched to =Tempel= instead of =Yasnippet=. With Copilot, the
suggestions is my snippet/template. Coupled with Eglot/LSP for
function/method-based templates, I rarely need a library of
snippets/templates. For the occasional needs that is specific to me/my workflow,
a more minimal template library like =Tempo=/=Tempel= is suffice.

I settled with =Tempel=, it polished some of the rough edges with =Tempo=, namely:

- Per-language/major-mode templates. =Tempo= does support this in the form of
  tags, however it requires some glue code, while =Tempel= has built-in support
- Temporary key map for moving between placeholders/poi/marks

Since the template definition is compatible between the 2, I can easily move to
=Tempo= in the future if it added support for the 2 points above.

#+begin_src emacs-lisp
  (use-package tempel
    :ensure t
    :hook (after-init . global-tempel-abbrev-mode)
    :bind (("M-+" . tempel-complete)
           ("M-*" . tempel-insert)))
#+end_src

  Tempo integration code for future reference:

#+begin_src emacs-lisp :tangle no
    (defun td/tempo-space-dwim ()
      (interactive "*")
      (or (tempo-expand-if-complete) (insert " ")))

    (defun td/tempo-forward-mark-dwim ()
      (interactive)
      (or (tempo-forward-mark) (forward-paragraph)))

    (use-package tempo
      :functions (tempo-define-template tempo-expand-if-complete)
      :bind (("M-+" . tempo-complete-tag)
             ("SPC" . td/tempo-space-dwim)
             ("M-}" . td/tempo-forward-mark-dwim))
      :custom
      (tempo-insert-region t)
      :init
      (tempo-define-template tempo-expand-if-complete)))
#+end_src

** Alignment

#+begin_src emacs-lisp
  (use-package align
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1))))
#+end_src

** Diff

#+begin_src emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-keep-variants nil)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally))
#+end_src


* Shell and remote

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :hook (after-init . exec-path-from-shell-initialize))
#+end_src

#+begin_src emacs-lisp
  (use-package envrc
    :ensure t
    :hook (after-init . envrc-global-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package comint
    :bind ("C-c C-l" . comint-clear-buffer))
#+end_src

#+begin_src emacs-lisp :tangle no
  (defun td/detached-notification-function (session)
    "Issue a notification when SESSION transitions from active to inactive.
  This function uses the `terminal-notifier' command line utility."
    (let ((status (detached-session-status session))
          (host (detached-session-host-name session)))
      (start-process
       "terminal-notifier"
       nil
       "terminal-notifier"
       "-sender" "org.gnu.Emacs"
       "-activate" "org.gnu.Emacs"
       "-title" (pcase status
                  ('success (format "Detached finished [%s]" host))
                  ('failure (format "Detached failed [%s]" host)))
       "-message" (detached-session-command session))))

  (use-package detached
    :ensure t
    :functions (detached-session-command
                detached-session-host-name
                detached-session-status)
    :hook (after-init . detached-init)
    :bind (([remap async-shell-command] . detached-shell-command)
           ([remap compile] . detached-compile-compile)
           ([remap recompile] . detached-compile-recompile)
           ("C-x C-d" . detached-open-session))
    :custom
    (detached-show-output-on-attach t)
    (detached-notification-function #'td/detached-notification-function))

  (connection-local-set-profile-variables
   'remote-detached
   '((detached-shell-program . "/bin/bash")
     (detached-session-directory . "/tmp/detached")))

  (connection-local-set-profiles
   '(:application tramp :protocol "ssh") 'remote-detached)
#+end_src

** EShell

#+begin_src emacs-lisp
  (use-package eshell-toggle
    :ensure t
    :bind* (("C-c C-s" . eshell-toggle))
    :custom
    (eshell-toggle-use-git-root t))

  (use-package eshell-up
    :ensure t
    :functions eshell-up
    :defer t
    :config
    (defalias 'eshell/up 'eshell-up))

  (use-package eshell-z
    :ensure t
    :functions eshell/z
    :defer t)

  ;; (use-package eshell-vterm
  ;;   :ensure t
  ;;   :defer t
  ;;   :hook (after-init . eshell-vterm-mode))

  (defun td/eshell-pwd ()
    (replace-regexp-in-string
     (regexp-quote (expand-file-name "~"))
     "~"
     (eshell/pwd)))

  (defun td/eshell-prompt ()
    (format
     "\n%s@%s in %s\n%s "
     (propertize user-login-name 'face '(:foreground "#dc322f"))
     (propertize (or (getenv "HOST") (system-name)) 'face '(:foreground "#b58900"))
     (propertize (td/eshell-pwd) 'face '(:foreground "#859900"))
     (if (= (user-uid) 0)
         (propertize "#" 'face '(:foreground "red")) "$")))

  (use-package eshell
    :functions (eshell/pwd)
    :custom
    (eshell-prompt-function #'td/eshell-prompt)
    (eshell-prompt-regexp "^[^#$\\n]*[#$] ")
    (eshell-highlight-prompt nil)
    (eshell-scroll-to-bottom-on-input t)
    :config
    (defalias 'eshell/e #'find-file)
    (with-eval-after-load "crux"
      (defalias 'eshell/open #'crux-open-with)))
#+end_src

** Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :custom
    (tramp-allow-unsafe-temporary-files t)
    (tramp-default-method "ssh")
    :config
    (add-to-list 'auth-sources (expand-file-name "authinfo.gpg" user-emacs-directory))
    (add-to-list 'auth-sources 'macos-keychain-generic t)
    (add-to-list 'tramp-connection-properties '("/ssh:" "direct-async-process" t)))
#+end_src

Some speedup for Tramp:

#+begin_src emacs-lisp
  (use-package vc
    :custom
    (vc-follow-symlinks t)
    (vc-handled-backends '(Git)))
#+end_src


* Programming

Native LSP support via =Eglot= since Emacs 29.1

#+begin_src emacs-lisp
  ;; https://github.com/fwcd/kotlin-language-server/blob/main/TROUBLESHOOTING.md
  (setenv "JAVA_OPTS" "-Xmx4g")
#+end_src

#+begin_src emacs-lisp
  (setq read-process-output-max (* 8 1024 1024))

  (use-package eglot
    :hook ((kotlin-ts-mode . eglot-ensure)
           (js-ts-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure)
           (tsx-ts-mode . eglot-ensure)
           (go-ts-mode . eglot-ensure)
           (ocaml-ts-mode . eglot-ensure)
           (tuareg-mode . eglot-ensure))
    :bind ("C-c C-a" . eglot-code-actions)
    :custom
    (eglot-autoshutdown t)
    (eglot-connect-timeout 300)
    (eglot-ignored-server-capabilities '(:documentFormattingProvider
                                         :documentRangeFormattingProvider
                                         :documentOnTypeFormattingProvider
                                         :documentHighlightProvider))
    :config
    (add-to-list 'eglot-server-programs '(kotlin-ts-mode "kotlin-language-server"))
    (add-to-list 'eglot-server-programs '(ocaml-ts-mode "ocamllsp"))
    ;; https://www.reddit.com/r/emacs/comments/17jrsmv/comment/k74b3tg/?utm_source=share&utm_medium=web2x&context=3
    ;; (advice-add 'jsonrpc--log-event :override #'ignore)
    )

  (use-package eglot-booster
    :after eglot
    :functions eglot-booster-mode
    :config	(eglot-booster-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package lsp-mode
    :ensure t
    :commands lsp
    :hook ((kotlin-ts-mode . lsp)
           (js-ts-mode . lsp)
           (typescript-ts-mode . lsp)
           (tsx-ts-mode . lsp)
           (go-mode . lsp)
           (tuareg-mode . lsp)
           (python-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-keymap-prefix "C-c l")
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-enable-indentation nil)
    (lsp-enable-on-type-formatting nil)
    (lsp-enable-symbol-highlighting nil))
#+end_src

#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (setq eldoc-display-functions '(eldoc-display-in-buffer)))
#+end_src

Native Tree-sitter support since Emacs 29

#+begin_src emacs-lisp
  (defun td/treesit-mark-node (node)
    (goto-char (treesit-node-start node))
    (call-interactively #'set-mark-command)
    (goto-char (treesit-node-end node)))

  (defun td/tressit-expand-region ()
    "Poor man's expand-region, worked surprisingly well for me"
    (interactive)
    (let ((start (if (region-active-p) (region-beginning) 1))
          (end (if (region-active-p) (region-end) 1))
          (node (if (region-active-p)
                    (treesit-node-parent
                     (treesit-node-on (region-beginning) (region-end)))
                  (treesit-node-at (point)))))
      (if (or (/= start (treesit-node-start node))
              (/= end (treesit-node-end node)))
          (td/treesit-mark-node node)
        (forward-char)
        (td/tressit-expand-region))))

  (bind-key "M--" #'td/tressit-expand-region)

  (use-package treesit
    :functions (treesit-node-on
                treesit-node-at
                treesit-node-parent
                treesit-node-start
                treesit-node-end)
    :config
    (add-to-list 'treesit-extra-load-path "/opt/local/lib")
    (add-to-list 'treesit-language-source-alist '(dockerfile . ("https://github.com/camdencheek/tree-sitter-dockerfile.git")))
    (add-to-list 'treesit-language-source-alist '(kotlin . ("https://github.com/fwcd/tree-sitter-kotlin.git")))
    (add-to-list 'treesit-language-source-alist '(org . ("https://github.com/milisims/tree-sitter-org.git")))
    (add-to-list 'treesit-language-source-alist '(nix . ("https://github.com/nix-community/tree-sitter-nix.git"))))

  (use-package typescript-ts-mode
    :mode (("\\.ts\\'" . tsx-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode)))

  ;; (use-package go-ts-mode
  ;;   :mode (("go.mod$" . go-mod-ts-mode)
  ;;          ("\\.go\\'" . go-ts-mode))
  ;;   :custom
  ;;   (go-ts-mode-indent-offset 2))

  (use-package dockerfile-ts-mode
    :mode ("Dockerfile$" . dockerfile-ts-mode))

  (use-package yaml-ts-mode
    :mode ("\\.yaml\\'" . yaml-ts-mode))

  (setq
   major-mode-remap-alist
   '((js-mode . js-ts-mode)
     (typescript-mode . typescript-ts-mode)
     (json-mode . json-ts-mode)
     (css-mode . css-ts-mode)
     ;; (python-mode . python-ts-mode)
     ))
#+end_src

** Auto completion

I use auto completion sparingly, using Corfu.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :hook (after-init . global-corfu-mode)
    :bind* (:map corfu-map
                 ("SPC" . corfu-insert-separator)
                 ("C-n" . corfu-next)
                 ("C-p" . corfu-previous))
    :custom
    (corfu-cycle t)
    (corfu-echo-documentation 0.1))
#+end_src

#+begin_src emacs-lisp
  (use-package dabbrev
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . completion-at-point)))
#+end_src

#+begin_src emacs-lisp
  (use-package copilot
    :load-path "/Users/tung/Projects/dotfiles/emacs/vendor/copilot"
    :functions copilot-mode
    :bind (("C-j" . copilot-accept-completion))
    :hook ((mhtml-mode . copilot-mode)
           (css-ts-mode . copilot-mode)
           (html-ts-mode . copilot-mode)
           (js-ts-mode . copilot-mode)
           (typescript-ts-mode . copilot-mode)
           (tsx-ts-mode . copilot-mode)
           (kotlin-ts-mode . copilot-mode)
           (go-ts-mode . copilot-mode)
           (go-mode . copilot-mode)
           (python-mode . copilot-mode)))
#+end_src

** Error checking

#+begin_src emacs-lisp
  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error)))
#+end_src

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x p v" . magit)
    :custom
    (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
    :config
    (remove-hook 'server-switch-hook 'magit-commit-diff)
    (remove-hook 'with-editor-filter-visit-hook 'magit-commit-diff))
#+end_src

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+begin_src emacs-lisp
  (require 'ansi-color)

  (defun td/colorize-compilation-buffer ()
    (read-only-mode -1)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (read-only-mode t))

  (use-package compile
    :bind ("C-c m" . recompile)
    :hook (compilation-filter . td/colorize-compilation-buffer)
    :custom
    (compilation-ask-about-save nil)
    (compilation-scroll-output t))
#+end_src

** Code folding

TDB: waiting for folding support with Treesitter

** Web Development

#+begin_src emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+end_src

#+begin_src emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook (mhtml-mode . emmet-mode)
    :bind ("C-M-<return>" . emmet-expand-line)
    :config
    (unbind-key "C-j" emmet-mode-keymap))
#+end_src

#+begin_src emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :mode "\\.css\\'"
    :config
    (setq css-indent-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook (css-mode . rainbow-mode))
#+end_src

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try.

#+begin_src emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . js-ts-mode))
    :config
    (setq js-indent-level 2
          js-indent-first-init 'dynamic
          js-switch-indent-offset 2
          js-enabled-frameworks '(javascript)))
#+end_src

** Python

** Haskell

I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
easy. There's also a catch-all IDE-like mode called =intero=, by the very
same folk who runs =stack=.

#+begin_src emacs-lisp :tangle no
  (use-package haskell-mode
    :ensure t
    :mode (("\\.hs\\'" . haskell-mode))
    :hook ((haskell-mode . copilot-mode)
           (haskell-mode . eglot-ensure))
    :bind (([remap haskell-mode-format-imports] . haskell-sort-imports))
    :custom
    (haskell-program-name "cabal repl"))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package lsp-haskell
    :ensure t
    :custom
    (lsp-haskell-server-path "haskell-language-server-wrapper"))
#+end_src

** OCaml

I'm a Python veteran. When I have the opportunity to, I tried to use
Haskell. Recently I have been looking into OCaml, it seems like a very good,
practical choice.

The following are the issues I have working in Python and Haskell, they are the
reason I'm considering OCaml as my main language. Hopefully I'll get a better
experience with OCaml. Besides the fact that OCaml is strongly-typed and can be
used for both the web and server, following are my bad experiences with either
Python or Haskell:

1. Python:
   - No good package manager: poetry used to be the silver bullet, combining
     =pyenv= and =pipenv=, while also fixing their issues. For what it's worth,
     Poetry is miles better than the previous solutions, yet it still suffers
     from problems that are unbearable for me.
   - The lack of types. That alone is a serious drawback for me. Sure I can add
     type annotations and use mypy, but unless libraries are also shipped with
     type definitions, those provides very limited guarantee, which defeats the
     purpose of having types in the first place.
   - Library breaking changes: cryptonite changed and broke my code producing
     APNS push packages. It can't be detected until it's shipped to production,
     so it's really bad.

 2. Haskell
   - Stack breaks.
   - The compiler is slow, and there's no good story regarding cross-compile. My
     guess is that the runtime is so sophisticated that it has to be linked to
     at least libc, hence making producing static binaries much harder.
   - Lack of production oriented library/framework. It's kind of like with
     Clojure, the libraries are there and they are excellent, but there is no
     standard bundle requiring a lot of wiring setting up a project. OCaml has Sihl.
   - I was told that OCaml is worse than Haskell regarding libraries, but in my
     experience that is not true. OCaml might have less libraries, but they are
     much more comprehensive and well-maintained. A lot of the libraries in the
     Haskell world seems to be a one-off experiment, or an one-time job then
     abandoned at best. (I'm talking about iCalendar, and there are many other cases).

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t)

  (use-package reason-mode
    :ensure t)
#+end_src

** Java

** Kotlin

#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :ensure t
    :mode (("\\.kt\\'" . kotlin-ts-mode)
           ("\\.kts\\'" . kotlin-ts-mode)))
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t
    :mode (("\\.tf" . terraform-mode))
    :custom (terraform-format-on-save t))
#+end_src

** SQL

#+begin_src emacs-lisp
  (use-package sqlformat
    :ensure t)

  (use-package sql
    :custom
    (sql-postgres-login-params
     '((user :default "postgres")
       (database :default "postgres")
       (server :default "localhost")
       (port :default 5432))))
#+end_src

** Misc

These are supports for other stuffs that I used:

#+begin_src emacs-lisp :tangle no
  (use-package nix-ts-mode
    :ensure t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode))
    :config
    ;; Requires 'pip3 install --user markdown'
    (setq markdown-command "python3 -m markdown -x extra"))
#+end_src


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time logging

#+begin_src emacs-lisp
  (use-package ob-plantuml
    :config
    (setq org-plantuml-jar-path "/opt/local/share/java/plantuml/plantuml.jar"))

  (defun td/org-electric-pair ()
    (setq-local
     electric-pair-inhibit-predicate
     `(lambda (c)
        (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))

  (use-package org
    :hook ((org-mode . org-indent-mode)
           (org-mode . td/org-electric-pair))
    :custom
    (org-directory "~/Documents/Journal")
    (org-default-notes-file (expand-file-name "inbox.org" org-directory))
    (org-agenda-files `(,org-directory))
    (org-agenda-skip-unavailable-files t)
    (org-hide-leading-stars t)
    (org-clock-persist 'history)
    ;; (org-refile-targets '(("~/Desktop/archive.org" . (:level . 1))))
    (org-startup-with-inline-images t)
    (org-todo-keywords
     '((sequence "TODO(t@)" "WAITING(w@)" "|" "DONE(d@/!)" "CANCELED(c@)")))
    (org-src-fontify-natively t)

    :config
    (require 'org-tempo)
    (org-clock-persistence-insinuate)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t)
       (plantuml . t)
       (python . t)
       (shell . t)
       (js . t)
       (kotlin . t)
       (sql . t))))
#+end_src

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/canceled)
- But don't have any todo items

#+begin_src emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :config
    (setq org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-stuck-projects
          '("+project+LEVEL=1/-WAITING-DONE-CANCELED" ("TODO" "WAITING") nil "")))
#+end_src

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

#+begin_src emacs-lisp
  (use-package org-capture
    :bind* (("C-c o c" . org-capture))
    :custom
    (org-capture-templates
     `(("t" "Inbox item" entry
        (file+headline "~/Desktop/inbox.org" "Inbox") nil)
       ("l" "TIL" entry
        (file+olp+datetree "~/Desktop/inbox.org" "TIL") nil
        :jump-to-captured t)
       ("b" "Blog" entry
        (file+olp+datetree "~/Desktop/inbox.org" "Blog") nil
        :jump-to-captured t))))
#+end_src

** Literate programming

Org Babel for literate programming and API documentation.

#+begin_src emacs-lisp
  (use-package ob-core
    :defer t
    :hook (org-babel-after-execute . org-display-inline-images)
    :custom
    (org-confirm-babel-evaluate nil))

  (use-package ob-http
    :defer t
    :ensure t
    :custom
    (ob-http:max-time 180)
    (ob-http:remove-cr t))

  (use-package ob-python
    :defer t
    :custom
    (org-babel-python-command "python3"))
#+end_src

** Spell checking

#+begin_src emacs-lisp :tangle no
  (use-package ispell
    :bind ("s-i" . ispell-word)
    :config
    (setq ispell-program-name "aspell"
          ispell-extra-args
          '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary")
          ispell-skip-html t
          ispell-silently-savep t
          ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :hook (org-mode . flyspell-mode))
#+end_src


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t
        visible-bell nil
        ring-bell-function 'ignore
        scroll-preserve-screen-position t
        scroll-margin 8
        scroll-conservatively 101
        auto-window-vscroll nil)

  ;; (pixel-scroll-precision-mode t)
#+end_src

I use mouse scroll a lot, and with the default key binding it would accidentally
change the text scale. I don't want this behavior, hence unbind the key here.

#+begin_src emacs-lisp
  (unbind-key "C-<mouse-5>")
  (unbind-key "C-<mouse-4>")
  (unbind-key "C-<wheel-down>")
  (unbind-key "C-<wheel-up>")
#+end_src

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+begin_src emacs-lisp
  (setq
   fringes-outside-margins t
   default-frame-alist
   `((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     ;; (font . "JetBrains Mono NL 14")
     ;; (font . "Monaco 14")
     ;; (font . "Agave 16")
     (font . "Ubuntu Mono 16")
     (tool-bar-lines . 0)
     (fullscreen . maximized)
     (ns-appearance . dark)
     (vertical-scroll-bars . nil)))

  (blink-cursor-mode -1)
  (tool-bar-mode -1)
  (setq-default cursor-in-non-selected-windows nil)

  (unless (display-graphic-p)
    (menu-bar-mode -1))
#+end_src

Hide unnecessary long mode line mode list

#+begin_src emacs-lisp
  (use-package minions :ensure t :hook (after-init . minions-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package hl-line :hook (after-init . global-hl-line-mode))
#+end_src

Truncate lines:

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indentation
    :ensure t
    :hook ((python-mode . highlight-indentation-mode)
           (yaml-mode . highlight-indentation-mode)
           (yaml-ts-mode . highlight-indentation-mode))
    :custom
    (highlight-indentation-blank-lines t))
#+end_src

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+begin_src emacs-lisp :tangle no
  (use-package tango-plus-theme
    :ensure t
    :init (load-theme 'tango-plus t))
#+end_src


#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :init (load-theme 'doom-badger t))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package modus-themes
    :init (load-theme 'modus-vivendi t)
    :custom
    (modus-themes-subtle-line-numbers t)
    (modus-themes-region '(bg-only))
    (modus-themes-deuteranopia t))
#+end_src

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(font-lock-comment-face ((t :slant normal)))
   '(font-lock-comment-delimiter-face ((t :slant normal)))
   '(font-lock-string-face ((t :slant normal)))
   '(font-lock-constant-face ((t :slant normal)))

   '(line-number ((t :slant normal)))
   '(line-number-current-line ((t :slant normal)))
   '(fringe ((t :inherit line-number :background unspecified)))
   ;;'(vertical-border ((t :foreground "#000")))

   ;;'(mode-line-buffer-id ((t :foreground "#deae3e")))
   ;;'(mode-line ((t :inherit line-number-current-line :foreground nil :background nil :box (:style 'flat))))
   ;;'(mode-line-inactive ((t :inherit line-number :background nil :foreground nil)))
   ;;'(cursor ((t :background "orange")))
   )
#+end_src

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+begin_src emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (use-package display-line-numbers
    :hook ((prog-mode . display-line-numbers-mode)
           (org-mode . display-line-numbers-mode))
    :custom
    (display-line-numbers-width-start 100))
#+end_src

The default line continuation indicator is too standout and distracting for me.

#+begin_src emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b10100000
     #b01010000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) '(nil halftone))
  (setcdr (assq 'truncation fringe-indicator-alist) '(nil halftone))
#+end_src

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+begin_src emacs-lisp
  (defun td/diff-hl-fringe-bmp (_type _pos) 'halftone)

  (defun td/diff-hl-overlay-modified (ov after-p beg end &optional len)
    "No-op. Markers disappear and reapear is annoying to me.")

  (use-package diff-hl
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :custom
    (diff-hl-draw-borders nil)
    (diff-hl-fringe-bmp-function #'td/diff-hl-fringe-bmp)
    (diff-hl-disable-on-remote t)
    :config
    (custom-theme-set-faces
     'user
     '(diff-hl-insert ((t (:inherit nil :background unspecified :foreground "#81af34"))))
     '(diff-hl-delete ((t (:inherit nil :background unspecified :foreground "#ff0000"))))
     '(diff-hl-change ((t (:inherit nil :background unspecified :foreground "#deae3e")))))

    (advice-add 'diff-hl-overlay-modified :override #'td/diff-hl-overlay-modified))
#+end_src


* Misc

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (dired-recursive-deletes 'always)
    (dired-auto-revert-buffer t))
#+end_src

#+begin_src emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Microsoft Edge\" to reload active tab of window 1'"))

  (bind-key* "C-M-r" #'td/refresh-front-most-tab)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package kubel
    :ensure t
    :defer t
    :custom
    (kubel-kubectl "/opt/local/bin/kubectl"))
#+end_src


* Ideas


* Init file generation

Where the magic happen!

#+begin_src text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.config/emacs/init.el")) nil t)
  # End:
#+end_src
