#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

So, as an effort to improve the responsiveness, I'm going to reboot my Emacs
configuration. Hope it is better this time.

The idea is that I'm going to add things in, bit by bit, just enough to get it
going. This way I will be able to nail down the packages that cause issue, and
look for alternatives.

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I
install them automatically with =use-package.el= instead of using =package.el=
directly.

I'm also trying out some of the start-up optimization tips from Doom.

So far the biggest save is coming from 'native-comp'

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  (eval-when-compile
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (require 'use-package))

  (setq package-quickstart t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package package
    :defer t
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
#+END_SRC

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package bind-key
    :ensure t
    :functions (override-global-mode)
    :config (override-global-mode t))

  (use-package delight :ensure t)
#+END_SRC

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+END_SRC


* Defaults

Personal information that some package use:

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Tung Dao"
        user-mail-address "me@tungdao.com"
        default-input-method 'vietnamese-telex)
  (defvar personal-keybindings nil)
#+END_SRC

Less verbose choice:

#+BEGIN_SRC emacs-lisp
  (setq use-short-answers t)
#+END_SRC

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil)
#+END_SRC

Performance stuffs, I'm not sure how relevant these are, since I've moved to =nativecomp=.

#+begin_src emacs-lisp
  (setq-default
   bidi-display-reordering nil
   bidi-paragraph-direction 'left-to-right
   bidi-inhibit-bpa t)

  (setq read-process-output-max (* 16 1024 1024)
        inhibit-compacting-font-caches t)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :functions exec-path-from-shell-copy-envs
    :hook (after-init . exec-path-from-shell-initialize)
    :config
    (exec-path-from-shell-copy-envs '("LANG")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
#+END_SRC

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.02)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package which-key
    :ensure t
    :delight
    :hook (after-init . which-key-mode)
    :config
    (setq which-key-show-early-on-C-h t)
    (setq which-key-idle-delay most-positive-fixnum)
    (setq which-key-idle-secondary-delay 1e-100))
#+end_src

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)

  (defun td/keyboard-quit-dwim ()
    (interactive)
    (if-let ((minibuffer (active-minibuffer-window)))
        (with-current-buffer (window-buffer minibuffer)
          (minibuffer-keyboard-quit))
      (funcall 'keyboard-quit)))

  (bind-key [remap keyboard-quit] #'td/keyboard-quit-dwim)
#+end_src

** Server

#+BEGIN_SRC emacs-lisp
  (defun td/ensure-server-running ()
    (require 'server)
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook #'td/ensure-server-running)
#+END_SRC


** MacOS specific stuffs

#+BEGIN_SRC emacs-lisp
  (setq ns-command-modifier 'meta
        ns-option-modifier 'super
        trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+END_SRC


* Navigation

** File position

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :hook (after-init . save-place-mode))
#+END_SRC

** Projects

Emacs built-in =project.el= has gone a long way so I'm using that now. There are
still some missing features coming from =projectile=, but I can live with that.

#+begin_src emacs-lisp
  (use-package project
    :commands (project-find-file project-current))
#+end_src

** Symbols

I used to use =dumb-jumb=, but LSP has gotten good enough and it supported all
of the languages that I use, so now I use the built-in =xref= and rely on LSP's
=xref= integration.

Default key bindings is

| Binding   | Command                              | Description |
|-----------+--------------------------------------+-------------|
| =M-.=     | =xref-find-definitions=              |             |
| =C-M-p=   | =xref-find-definitions-other-window= |             |
| =C-M-g=   | =xref-pop-marker-stack=              |             |

#+begin_src emacs-lisp
  (use-package xref
    :bind (("C-M-p" . xref-find-definitions-other-window)
           ("C-M-g" . xref-go-back)))

  (bind-key* "C-M-." #'xref-find-definitions)
#+end_src

** Vertico

Vertico is the next in line for vertical completion.

#+begin_src emacs-lisp
  (ido-mode -1)

  (defun td/minibuffer-smart-tilde ()
    (interactive)
    (if (not (looking-back "/" 0))
        (call-interactively 'self-insert-command)
      (beginning-of-line)
      (kill-line)
      (insert "~/")))

  (bind-key "~" #'td/minibuffer-smart-tilde minibuffer-local-map)
  (bind-key "<s-backspace>" #'backward-kill-word minibuffer-local-map)
#+end_src

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :hook (after-init . vertico-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-M-l" . consult-line)
           ("C-M-j" . consult-buffer)
           ("M-g b" . consult-bookmark)
           ("M-g y" . consult-yank-from-kill-ring)
           ("M-g t" . consult-theme)
           ("M-g m" . consult-mode-command)
           ("M-g r" . consult-ripgrep)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap imenu] . consult-imenu))
    :custom
    (consult-narrow-key (kbd "<"))
    (consult-project-root-function #'vc-root-dir)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))

  (use-package consult-flymake
    :bind ("M-g e" . consult-flymake))
#+end_src

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 128)
    :config
    (add-to-list 'recentf-exclude "elpa/.*")
    (add-to-list 'recentf-exclude "__init__.py")
    (add-to-list 'recentf-exclude "node_modules/.*"))
#+end_src

#+begin_src emacs-lisp
  (bind-key* "M-m" #'execute-extended-command)
#+end_src

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless flex basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src


* Window Management

Split windows horizontally by default.

#+begin_src emacs-lisp
  (setq split-width-threshold 120
        split-height-threshold 0)
#+end_src

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind* (("M-j" . ace-window)
            ("M-J" . ace-delete-window)))
#+end_src

Temporary "focus" on a buffer by maximizing it in the current frame.

#+begin_src emacs-lisp
  (defun td/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (bind-key* [remap delete-other-windows] #'td/toggle-maximize-buffer)
#+end_src

Buffer location customization

#+begin_src emacs-lisp
  (use-package window
    :config
    (add-to-list 'display-buffer-alist
                 '("^\\*eldoc for" display-buffer-at-bottom
                   (window-height . 4)))
    (add-to-list 'display-buffer-alist
                 '("^\\*compilation" display-buffer-at-bottom
                   (window-height . 4)))
    (add-to-list 'display-buffer-alist
                 '("^\\*Org-Babel Error Output*" display-buffer-at-bottom
                   (window-height . 4)))
    )
#+end_src


* General Editing

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :hook (after-init . evil-mode)
    :custom
    (evil-cross-lines t)
    (evil-ex-substitute-global t)
    (evil-undo-system 'undo-redo))

  (use-package evil-surround
    :ensure t
    :hook (evil-mode . global-evil-surround-mode))
#+end_src

#+BEGIN_SRC emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer))
#+END_SRC

#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

Basic settings:

#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width 2
   indent-tabs-mode nil
   require-final-newline t
   reb-re-syntax 'string)
#+END_SRC

Editing utilities:

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t
    :hook (after-init . crux-reopen-as-root-mode)
    :bind (("M-C-]" . crux-switch-to-previous-buffer)
           ("M-J" . crux-top-join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c C-o" . crux-open-with)
           ([remap kill-line] . crux-smart-kill-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save)
    (setq kill-do-not-save-duplicates t))

  (bind-key* "C-c C-k" #'kill-this-buffer)
  (bind-key* "s-n" #'next-buffer)
  (bind-key* "s-p" #'previous-buffer)
  (bind-key [remap just-one-space] #'cycle-spacing)
#+END_SRC

Create directory for the file if not exists:

#+BEGIN_SRC emacs-lisp
  (defun td/make-new-directories ()
    (let ((dir (file-name-directory buffer-file-name)))
      (when (and buffer-file-name (not (file-exists-p dir)))
        (make-directory dir t))))

  (add-to-list 'find-file-not-found-functions #'td/make-new-directories)
#+END_SRC

Make the file executable if starting with "shebang":

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Search and replace

#+begin_src emacs-lisp
  (use-package visual-regexp
    :ensure t
    :bind (("M-r" . vr/query-replace)
           ([remap query-replace] . vr/query-replace)
           ("C-M-r" . vr/mc-mark)))
#+end_src

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+BEGIN_SRC emacs-lisp
  (delight 'auto-fill-function "" t)
  (delight 'auto-revert-mode "" t)

  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+END_SRC

** Whitespace

Cleanup whitespaces automatically on save.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup))
#+END_SRC

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
use =smart-parens= to manage them. However the command name use words from an
arcane language :(, so I put together a table of human-readable description of
the commands. All key bindings are started with =M-s=.

| Bindings  | Command                | Description                                         |
|-----------+------------------------+-----------------------------------------------------|
| =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
| =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
| =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
| =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

NOTE: This package is huge, I'm still learning it.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smartparens
    :ensure t
    :delight smartparens-mode
    :hook ((prog-mode . smartparens-mode))
    :bind (("M-s DEL" . sp-splice-sexp)
           ("M-S" . sp-rewrap-sexp)
           ("M-s <right>" . sp-slurp-hybrid-sexp)
           ("C-S-f" . sp-slurp-hybrid-sexp)
           ("M-s <left>" . sp-forward-barf-sexp)
           ("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("M-K" . sp-kill-sexp)
           ("M-]" . sp-select-next-thing))
    :config
    (sp-pair "{" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :hook (after-init . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-context-when-offscreen t))

  (use-package elec-pair
    :hook (after-init . electric-pair-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)

  (use-package delsel
    :hook (after-init . delete-selection-mode))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :delight yas-minor-mode
    :hook (after-init . yas-global-mode)
    :config
    (setq yas-prompt-functions
          '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
          yas-verbosity 1)

    ;; I'm an old Emacs hacker, I like the abbrev-way and bind yas-expand SPC
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    (unbind-key "TAB" yas-minor-mode-map)
    (unbind-key "<tab>" yas-minor-mode-map))
#+END_SRC

** Alignment

#+BEGIN_SRC emacs-lisp
  (use-package align
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1))))
#+END_SRC

** Diff

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally))
#+END_SRC


* Shell and remote

#+begin_src emacs-lisp
  (use-package comint
    :bind ("C-c C-l" . comint-clear-buffer))
#+end_src

** EShell

#+BEGIN_SRC emacs-lisp
  (use-package eshell-toggle
    :ensure t
    :bind* (("C-c C-s" . eshell-toggle))
    :custom
    (eshell-toggle-use-git-root t))

  (use-package eshell-up
    :ensure t
    :functions eshell-up
    :defer t
    :config
    (defalias 'eshell/up 'eshell-up))

  (use-package eshell-z
    :ensure t
    :functions eshell/z
    :defer t)

  (defun td/eshell-pwd ()
    (replace-regexp-in-string
     (regexp-quote (expand-file-name "~"))
     "~"
     (eshell/pwd)))

  (defun td/eshell-prompt ()
    (format
     "\n%s@%s in %s\n%s "
     (propertize user-login-name 'face '(:foreground "#dc322f"))
     (propertize (or (getenv "HOST") (system-name)) 'face '(:foreground "#b58900"))
     (propertize (td/eshell-pwd) 'face '(:foreground "#859900"))
     (if (= (user-uid) 0)
         (propertize "#" 'face '(:foreground "red")) "$")))

  (use-package eshell
    :defer t
    :functions (eshell/pwd)
    :custom
    (eshell-prompt-function #'td/eshell-prompt)
    (eshell-prompt-regexp "^[^#$\\n]*[#$] ")
    (eshell-highlight-prompt nil)
    :config
    (defalias 'eshell/e #'find-file)
    (with-eval-after-load "crux"
      (defalias 'eshell/open #'crux-open-with)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package with-editor
    :ensure t
    :hook ((term-exec . with-editor-export-editor)
           (shell-mode . with-editor-export-editor)
           (eshell-mode . with-editor-export-editor)))
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (eval-and-compile
      (setq password-cache-expiry nil
            ;; tramp-debug-buffer t
            tramp-default-method "scp"
            tramp-verbose 1)

      (add-to-list 'auth-sources "~/Projects/dotfiles/dotfiles/.emacs.d/authinfo.gpg")
      (add-to-list 'auth-sources 'macos-keychain-generic t)
      (setq ange-ftp-netrc-filename "~/Projects/dotfiles/dotfiles/.emacs.d/authinfo.gpg")))
#+END_SRC

Some speedup for Tramp:

#+begin_src emacs-lisp
  (use-package vc
    :custom
    (vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
    (vc-follow-symlinks t)
    (vc-handled-backends '(Git)))
#+end_src


* Programming

Eglot, as the main LSP interface.

#+begin_src emacs-lisp
  (use-package eglot
    :preface
    (defun td/eglot-eldoc ()
      (setq eldoc-documentation-strategy
            'eldoc-documentation-compose-eagerly))
    :hook ((kotlin-ts-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure)
           (tsx-ts-mode . eglot-ensure)
           (gleam-ts-mode . eglot-ensure)
           (eglot-managed-mode . td/eglot-eldoc))
    :bind (("C-c C-r" . eglot-rename)
           ("C-c C-i" . eglot-code-action-organize-import))
    :config
    (add-to-list 'eglot-server-programs '(typescript-ts-mode . ("typescript-language-server" "--stdio")))
    (add-to-list 'eglot-server-programs '(tsx-ts-mode . ("typescript-language-server" "--stdio")))
    :custom
    (eglot-autoshutdown t))
#+end_src

#+begin_src emacs-lisp
  (defun td/eldoc-select-doc-buffer (_doc interactive)
    (when interactive
    (run-at-time 0.1 nil #'pop-to-buffer "*eldoc*")))

  (use-package eldoc
    :bind ("C-h C-h" . eldoc-print-current-symbol-info)
    :delight eldoc-mode
    :config
    (global-eldoc-mode -1)
    (advice-add 'eldoc-display-in-buffer :after #'td/eldoc-select-doc-buffer)
    :custom
    (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
    (eldoc-display-functions '(eldoc-display-in-buffer)))
#+end_src

Native Tree-sitter support since Emacs 29

#+begin_src emacs-lisp
  (use-package treesit
    :config
    (add-to-list 'treesit-language-source-alist '(dockerfile . ("https://github.com/camdencheek/tree-sitter-dockerfile.git")))
    (add-to-list 'treesit-extra-load-path "~/.local/lib")
    (add-to-list 'treesit-extra-load-path "/opt/local/lib"))

  (use-package typescript-ts-mode
    :mode ("\\.ts\\'" . tsx-ts-mode))
#+end_src

** Auto completion

I use auto completion sparingly, using Corfu.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :hook (after-init . global-corfu-mode)
    :bind* (:map corfu-map
                 ("SPC" . corfu-insert-separator)
                 ("C-n" . corfu-next)
                 ("C-p" . corfu-previous))
    :custom
    (corfu-cycle t)
    (corfu-echo-documentation 0.1))

  (use-package cape
    :ensure t
    :functions cape-file cape-wrap-silent cape-wrap-purify
    :config
    (add-to-list 'completion-at-point-functions #'cape-file)
    ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)

    ;; Silence the pcomplete capf, no errors or messages!
    ;; Important for corfu
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))

  (use-package dabbrev
    :bind (("M-/" . dabbrev-expand)
           ("C-M-/" . completion-at-point)))
#+end_src

** Error checking

Flymake have a rewrite in Emacs 26.1. I'm giving it a try now

#+BEGIN_SRC emacs-lisp
  (defun flymake-proc-create-temp-in-tmp (file-name)
    (concat temporary-file-directory file-name))

  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error))
    :config
    (advice-add
     'flymake-proc-create-temp-inplace
     :filter-return #'flymake-proc-create-temp-in-tmp))
#+END_SRC

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x p v" . magit)
    :custom
    (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1))
#+END_SRC

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+BEGIN_SRC emacs-lisp
  (require 'ansi-color)

  (defun td/colorize-compilation-buffer ()
    (read-only-mode -1)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (read-only-mode t))

  (use-package compile
    :bind ("C-c m" . recompile)
    :hook (compilation-filter . td/colorize-compilation-buffer)
    :custom
    (compilation-ask-about-save nil)
    (compilation-scroll-output 'first-error))
#+END_SRC

** Code folding

#+BEGIN_SRC emacs-lisp :tangle no
  (define-fringe-bitmap 'hideshow-fringe-marker [255] nil 16 '(top t))

  (defun td/hideshow-set-up-overlay (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put
       ov 'before-string (propertize "|" 'display '(left-fringe hideshow-fringe-marker)))
      (overlay-put
       ov 'display (propertize " …" 'face 'font-lock-comment-face))))

  (use-package hideshow
    :hook (prog-mode . hs-minor-mode)
    :custom
    (hs-hide-comments-when-hiding-all nil)
    (hs-set-up-overlay #'td/hideshow-set-up-overlay))

  (use-package hideshow-org
    :ensure t
    :hook (hs-minor-mode . hs-org/minor-mode))
#+END_SRC

** Web Development

Also, I can't live without Emmet.

#+BEGIN_SRC emacs-lisp
  (defun td/emmet-jsx-mode ()
    (interactive)
    (when (string-suffix-p "sx" (buffer-file-name))
      (setq-local emmet-expand-jsx-className? t)))

  (use-package emmet-mode
    :ensure t
    :delight emmet-mode
    :hook ((sgml-mode . emmet-mode)
           (css-mode . emmet-mode)
           (html-ts-mode . emmet-mode)
           (reason-mode . emmet-mode)
           (js-mode . emmet-mode)
           (js-ts-mode . emmet-mode)
           (tsx-ts-mode . emmet-mode))
    :config
    (setq emmet-indentation 2
          emmet-preview-default nil
          emmet-insert-flash-time 0.1)

    (add-hook 'emmet-mode-hook #'td/emmet-jsx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css\\'"
    :config
    (setq css-indent-offset 2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook (css-mode . rainbow-mode))
#+END_SRC

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try.

#+BEGIN_SRC emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . js-ts-mode))
    :config
    (setq js-indent-level 2
          js-indent-first-init 'dynamic
          js-switch-indent-offset 2
          js-enabled-frameworks '(javascript)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode (("\\.py\\'" . python-ts-mode))
    ;; :hook (before-save . py-isort-before-save)
    :config
    (setq python-fill-docstring-style 'django))
#+END_SRC

** Haskell

I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
easy. There's also a catch-all IDE-like mode called =intero=, by the very
same folk who runs =stack=.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package haskell-mode
    :ensure t
    :mode (("\\.hs\\'" . haskell-mode))
    :bind (([remap haskell-mode-format-imports] . haskell-sort-imports))
    :custom
    (haskell-program-name "stack repl"))
#+END_SRC

** OCaml

I'm a Python veteran. When I have the opportunity to, I tried to use
Haskell. Recently I have been looking into OCaml, it seems like a very good,
practical choice.

The following are the issues I have working in Python and Haskell, they are the
reason I'm considering OCaml as my main language. Hopefully I'll get a better
experience with OCaml. Besides the fact that OCaml is strongly-typed and can be
used for both the web and server, following are my bad experiences with either
Python or Haskell:

1. Python:
   - No good package manager: poetry used to be the silver bullet, combining
     =pyenv= and =pipenv=, while also fixing their issues. For what it's worth,
     Poetry is miles better than the previous solutions, yet it still suffers
     from problems that are unbearable for me.
   - The lack of types. That alone is a serious drawback for me. Sure I can add
     type annotations and use mypy, but unless libraries are also shipped with
     type definitions, those provides very limited guarantee, which defeats the
     purpose of having types in the first place.
   - Library breaking changes: cryptonite changed and broke my code producing
     APNS push packages. It can't be detected until it's shipped to production,
     so it's really bad.

 2. Haskell
   - Stack breaks.
   - The compiler is slow, and there's no good story regarding cross-compile. My
     guess is that the runtime is so sophisticated that it has to be linked to
     at least libc, hence making producing static binaries much harder.
   - Lack of production oriented library/framework. It's kind of like with
     Clojure, the libraries are there and they are excellent, but there is no
     standard bundle requiring a lot of wiring setting up a project. OCaml has Sihl.
   - I was told that OCaml is worse than Haskell regarding libraries, but in my
     experience that is not true. OCaml might have less libraries, but they are
     much more comprehensive and well-maintained. A lot of the libraries in the
     Haskell world seems to be a one-off experiment, or an one-time job then
     abandoned at best. (I'm talking about iCalendar, and there are many other cases).

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t)

  (use-package reason-mode
    :ensure t)
#+end_src

** Java

** Kotlin

#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :ensure t
    :mode (("\\.kt\\'" . kotlin-ts-mode)
           ("\\.kts\\'" . kotlin-ts-mode)))
#+end_src

** Docker

I use Docker for almost every project now, it is useful even just for setting up
consistent development environment across the team. I use =docker= package to
manage Docker images and containers.

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t)

  (use-package dockerfile-ts-mode
    :mode ("Dockerfile$" . dockerfile-ts-mode))

  (use-package kubel
    :ensure t)
#+END_SRC

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t
    :mode (("\\.tf" . terraform-mode)))
#+end_src

** SQL

#+begin_src emacs-lisp
  (use-package sqlformat
    :ensure t)

  (use-package sql
    :custom
    (sql-postgres-login-params
     '((user :default "postgres")
       (database :default "postgres")
       (server :default "localhost")
       (port :default 5432))))
#+end_src

** Misc

These are supports for other stuffs that I used:

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode))
    :config
    ;; Requires 'pip3 install --user markdown'
    (setq markdown-command "python3 -m markdown -x extra"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode
    :ensure t
    :mode (".*nginx.*\\.conf$" . nginx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package feature-mode
    :ensure t
    :mode (("\\.feature$" . markdown-mode)))
#+END_SRC

* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time logging

#+BEGIN_SRC emacs-lisp
  (use-package ob-async
    :ensure t
    :config
    (require 'ob-async))

  (use-package ob-plantuml
    :config
    (setq org-plantuml-jar-path "/opt/local/share/java/plantuml.jar"))

  (defun td/org-electric-pair ()
    (setq-local
     electric-pair-inhibit-predicate
     `(lambda (c)
        (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))

  (use-package org
    :hook ((org-mode . org-indent-mode)
           (org-mode . td/org-electric-pair))
    :delight org-indent-mode
    :custom
    (org-directory "~/Documents/Journal")
    (org-default-notes-file (expand-file-name "inbox.org" org-directory))
    (org-agenda-files `(,org-directory))
    (org-agenda-skip-unavailable-files t)
    (org-hide-leading-stars t)
    (org-clock-persist 'history)
    ;; (org-refile-targets '(("~/Desktop/archive.org" . (:level . 1))))
    (org-startup-with-inline-images t)
    (org-todo-keywords
     '((sequence "TODO(t@)" "WAITING(w@)" "|" "DONE(d@/!)" "CANCELED(c@)")))
    (org-src-fontify-natively t)

    :config
    (org-clock-persistence-insinuate)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t)
       (plantuml . t)
       (graphql . t)
       (python . t)
       (shell . t)
       (sql . t))))
#+END_SRC

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/canceled)
- But don't have any todo items

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :config
    (setq org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-stuck-projects
          '("+project+LEVEL=1/-WAITING-DONE-CANCELED" ("TODO" "WAITING") nil "")))
#+END_SRC

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

#+begin_src emacs-lisp
  (use-package org-capture
    :bind* (("C-c o c" . org-capture))
    :custom
    (org-capture-templates
     `(("t" "Inbox item" entry
        (file+headline "~/Desktop/inbox.org" "Inbox") nil)
       ("l" "TIL" entry
        (file+olp+datetree "~/Desktop/inbox.org" "TIL") nil
        :jump-to-captured t)
       ("b" "Blog" entry
        (file+olp+datetree "~/Desktop/inbox.org" "Blog") nil
        :jump-to-captured t))))
#+end_src

** Literate programming

Org Babel for literate programming and API documentation.

#+BEGIN_SRC emacs-lisp
  (use-package ob-core
    :defer t
    :hook (org-babel-after-execute . org-display-inline-images)
    :custom
    (org-confirm-babel-evaluate nil))

  (use-package ob-http
    :defer t
    :ensure t)

  (use-package ob-graphql
    :defer t
    :ensure t)
#+END_SRC

** Spell checking

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :bind ("s-i" . ispell-word)
    :config
    (setq ispell-program-name "aspell"
          ispell-extra-args
          '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary")
          ispell-skip-html t
          ispell-silently-savep t
          ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :delight flyspell-mode
    :hook (org-mode . flyspell-mode))
#+END_SRC


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        visible-bell nil
        ring-bell-function 'ignore
        scroll-preserve-screen-position t
        scroll-margin 8
        scroll-conservatively 101
        auto-window-vscroll nil
        fast-but-imprecise-scrolling t)
#+END_SRC

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+BEGIN_SRC emacs-lisp
  (setq
   fringes-outside-margins t
   ;; line-spacing 4
   default-frame-alist
   `((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     (ns-appearance . dark)
     (font . "Monaco 14")
     (vertical-scroll-bars . nil)
     (tool-bar-lines . 0)))

  (blink-cursor-mode -1)
  ;(load-theme 'deeper-blue t)
#+END_SRC

#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :init (load-theme 'doom-peacock t))
#+end_src

#+begin_src emacs-lisp
  (use-package hl-line
    :hook (after-init . global-hl-line-mode))
#+end_src

#+BEGIN_SRC emacs-lisp
  (setq ns-use-native-fullscreen t)
#+END_SRC

Truncate lines:

#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(vertical-border ((t (:foreground "#000" :background "#000"))))
   '(font-lock-comment-face ((t (:slant normal))))
   '(font-lock-comment-delimiter-face ((t (:slant normal))))
   '(font-lock-string-face ((t (:slant normal))))
   '(font-lock-constant-face ((t (:slant normal))))

   '(org-block ((t (:inherit default))))

   '(fringe ((t (:background unspecified))))
   '(line-number ((t :slant normal)))
   '(line-number-current-line ((t :slant normal)))

   '(hl-line ((t :foreground unspecified :background "#323850")))

   '(markdown-inline-code-face ((t (:slant normal))))

   '(indent-guide-face ((t (:inherit font-lock-comment-face)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package highlight-numbers
    :ensure t
    :defer t
    :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (setq-default display-line-numbers-width 3)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'html-ts-mode #'display-line-numbers-mode)
#+END_SRC

The default line continuation indicator is too standout and distracting for me.

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b01000000
     #b10000000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
  (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (eval-and-compile
      (setq rainbow-delimiters-max-face-count 1)

      (custom-theme-set-faces
       'user
       '(rainbow-delimiters-unmatched-face ((t (:inherit error :background "#f00")))))))
#+END_SRC

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'td/diff-hl-bmp [#b11110000] 1 8 '(top t))

  (defun td/diff-hl-fringe-bmp (_type _pos) 'td/diff-hl-bmp)

  (defun td/diff-hl-overlay-modified (ov after-p beg end &optional len)
    "No-op. Markers disappear and reapear is kind of annoying to me.")

  (use-package diff-hl
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :custom
    (diff-hl-draw-borders nil)
    (diff-hl-fringe-bmp-function #'td/diff-hl-fringe-bmp)
    :config
    (custom-theme-set-faces
     'user
     '(diff-hl-insert ((t (:inherit nil :background unspecified :foreground "#81af34"))))
     '(diff-hl-delete ((t (:inherit nil :background unspecified :foreground "#ff0000"))))
     '(diff-hl-change ((t (:inherit nil :background unspecified :foreground "#deae3e")))))

    (advice-add 'diff-hl-overlay-modified :override #'td/diff-hl-overlay-modified))
#+END_SRC

* Misc

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :defer t
    :config
    (setq dired-recursive-deletes 'always))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Microsoft Edge\" to reload active tab of window 1'"))

  (bind-key* "C-M-r" #'td/refresh-front-most-tab)
#+END_SRC


* Ideas

** Misc.
- https://github.com/raxod502/radian/blob/develop/emacs/radian.el#L3210


* Init file generation

Where the magic happen!

#+BEGIN_SRC text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.config/emacs/init.el")) nil t)
  # End:
#+END_SRC
