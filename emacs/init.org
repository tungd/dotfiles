#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

So, as an effort to improve the responsiveness, I'm going to reboot my Emacs
configuration. Hope it is better this time.

The idea is that I'm going to add things in, bit by bit, just enough to get it
going. This way I will be able to nail down the packages that cause issue, and
look for alternatives.

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I
install them automatically with =use-package.el= instead of using =package.el=
directly.

I'm also trying out some of the start-up optimization tips from Doom.

But so the biggest save is coming from 'native-comp'

#+begin_src emacs-lisp
  (setq comp-speed 2)
#+end_src

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package))

  (setq package-quickstart t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package bind-key)
  (use-package delight :ensure t)
#+END_SRC

Use a dedicate custom file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+END_SRC

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+END_SRC


* Defaults

Personal information that some package use:

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Tung Dao"
        user-mail-address "me@tungdao.com"
        default-input-method 'vietnamese-telex)
  (defvar personal-keybindings nil)
#+END_SRC

Less verbose choice:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil)
#+END_SRC

Performance stuffs, I'm not sure how relevant these are, since I've moved to =nativecomp=.

#+begin_src emacs-lisp
  (setq-default bidi-display-reordering nil)

  (setq read-process-output-max (* 8 1024 1024)
        inhibit-compacting-font-caches t)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :hook (after-init . exec-path-from-shell-initialize)
    :config
    (exec-path-from-shell-copy-envs '("LANG")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)

  (use-package prescient
    :ensure t
    :hook (after-init . prescient-persist-mode))
#+END_SRC

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.02)

  (use-package which-key
    :ensure t
    :delight
    :hook (after-init . which-key-mode)
    :config
    (setq which-key-show-early-on-C-h t)
    (setq which-key-idle-delay most-positive-fixnum)
    (setq which-key-idle-secondary-delay 1e-100))
#+end_src

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)

  (defun td/keyboard-quit-dwim ()
    (interactive)
    (if-let ((minibuffer (active-minibuffer-window)))
        (with-current-buffer (window-buffer minibuffer)
          (minibuffer-keyboard-quit))
      (funcall 'keyboard-quit)))

  (bind-key [remap keyboard-quit] #'td/keyboard-quit-dwim)
#+end_src

** Server

#+BEGIN_SRC emacs-lisp
  (defun td/ensure-server-running ()
    (require 'server)
    (unless (server-running-p)
      (server-start)))

  (add-hook 'after-init-hook #'td/ensure-server-running)
#+END_SRC


** MacOS specific stuffs

#+BEGIN_SRC emacs-lisp
  (setq ns-command-modifier 'meta
        ns-option-modifier 'super
        trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+END_SRC


* Navigation

** File position

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :hook (after-init . save-place-mode))
#+END_SRC

** Projects

Emacs built-in =project.el= has gone a long way so I'm using that now. There are
still some missing features coming from =projectile=, but I can live with that.

#+begin_src emacs-lisp :tangle no
  (use-package project
    :commands (project-find-file project-current)
    :bind (("C-M-'" . project-find-file)))
#+end_src

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :hook (after-init . projectile-mode)
    :commands (projectile-find-file)
    :bind (:map projectile-mode-map
           ("C-M-'" . projectile-find-file)
           ("C-x p" . projectile-command-map)))
#+end_src

** Symbols

I used to use =dumb-jumb=, but LSP has gotten good enough and it supported all
of the languages that I use, so now I use the built-in =xref= and rely on LSP's
=xref= integration.

Default key bindings is

| Binding   | Command                              | Description |
|-----------+--------------------------------------+-------------|
| =M-.=     | =xref-find-definitions=              |             |
| =C-M-p=   | =xref-find-definitions-other-window= |             |
| =C-M-g=   | =xref-pop-marker-stack=              |             |

#+begin_src emacs-lisp
  (use-package xref
    :bind (("C-M-p" . xref-find-definitions-other-window)
           ("C-M-g" . xref-pop-marker-stack)))

  (bind-key* "C-M-." #'xref-find-definitions)
#+end_src

** Selectrum

Selectrum is one of the many packages that provide vertical completion for Emacs
command, similar to Ivy or Helm. What set it aside is the fact that it is built
upon =completing-read=, instead of wrapping it like the others, which make it
quite minimal but is very very fast.

#+begin_src emacs-lisp
  (ido-mode -1)

  (defun td/minibuffer-smart-tilde ()
    (interactive)
    (if (not (looking-back "/" 0))
        (call-interactively 'self-insert-command)
      (beginning-of-line)
      (kill-line)
      (insert "~/")))

  (bind-key "~" #'td/minibuffer-smart-tilde minibuffer-local-map)
  (bind-key "<s-backspace>" #'backward-kill-word minibuffer-local-map)
#+end_src

#+begin_src emacs-lisp
  (use-package selectrum
    :ensure t
    :hook (after-init . selectrum-mode))

  (use-package selectrum-prescient
    :ensure t
    :hook (after-init . selectrum-prescient-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-M-l" . consult-line)
           ("C-M-j" . consult-buffer)
           ("M-g b" . consult-bookmark)
           ("M-g y" . consult-yank-from-kill-ring)
           ("M-g t" . consult-theme)
           ("M-g m" . consult-mode-command)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ;; ([remap isearch-forward] . consult-isearch)
           )
    :bind* (("C-x p s" . consult-ripgrep))
    :custom
    (consult-preview-key (kbd "M-p"))
    (consult-narrow-key (kbd "<"))
    (consult-project-root-function #'vc-root-dir)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))
#+end_src

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 128)
    :config
    (add-to-list 'recentf-exclude "elpa/.*")
    (add-to-list 'recentf-exclude "__init__.py")
    (add-to-list 'recentf-exclude "node_modules/.*"))
#+end_src

#+begin_src emacs-lisp
  (bind-key* "M-m" #'execute-extended-command)
#+end_src


* Window Management

Split windows horizontally by default.

#+begin_src emacs-lisp
  (setq split-width-threshold 120
        split-height-threshold 0)
#+end_src

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind* (("M-j" . ace-window)
            ("M-J" . ace-delete-window)))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package golden-ratio
    :ensure t
    :hook (after-init . golden-ratio-mode)
    :delight golden-ratio-mode
    :config
    ;; Compatibility with ace-window
    (eval-after-load 'ace-window
      (advice-add 'ace-select-window :after #'golden-ratio)))
#+end_src

Temporary "focus" on a buffer by maximizing it in the current frame.

#+begin_src emacs-lisp
  (defun td/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (bind-key* [remap delete-other-windows] #'td/toggle-maximize-buffer)
#+end_src


* General Editing

#+BEGIN_SRC emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
    :ensure t
    :bind ([remap comment-dwim] . comment-dwim-2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer))
#+END_SRC

Basic settings:

#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width 2
   indent-tabs-mode nil
   require-final-newline t
   reb-re-syntax 'string)
#+END_SRC

Editing utilities:

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t
    :hook (after-init . crux-reopen-as-root-mode)
    :bind (("M-C-]" . crux-switch-to-previous-buffer)
           ("M-J" . crux-top-join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c C-o" . crux-open-with)
           ([remap kill-line] . crux-smart-kill-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save)
    (setq kill-do-not-save-duplicates t))

  (bind-key* "C-c C-k" #'kill-this-buffer)
  (bind-key* "s-n" #'next-buffer)
  (bind-key* "s-p" #'previous-buffer)
  (bind-key [remap just-one-space] #'cycle-spacing)
#+END_SRC

Create directory for the file if not exists:

#+BEGIN_SRC emacs-lisp
  (defun td/make-new-directories ()
    (let ((dir (file-name-directory buffer-file-name)))
      (when (and buffer-file-name (not (file-exists-p dir)))
        (make-directory dir t))))

  (add-to-list 'find-file-not-found-functions #'td/make-new-directories)
#+END_SRC

Make the file executable if starting with "shebang":

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :hook (after-init . evil-mode)
    :custom
    (evil-cross-lines t)
    (evil-ex-substitute-global t)
    (evil-undo-system 'undo-redo))

  (use-package evil-surround
    :ensure t
    :hook (evil-mode . global-evil-surround-mode))
#+end_src

** Search and replace

#+begin_src emacs-lisp :tangle no
  (use-package visual-regexp
    :ensure t
    :bind (("M-r" . vr/query-replace)
           ([remap query-replace] . vr/query-replace)
           ("C-M-r" . vr/mc-mark)))
#+end_src

#+begin_src emacs-lisp
  (use-package ctrlf
    :ensure t
    :hook (after-init . ctrlf-mode))
#+end_src

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+BEGIN_SRC emacs-lisp
  (delight 'auto-fill-function "" t)

  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+END_SRC

Sometimes long lines are inevitable though, as I do have to manually edit
exported SVG and minified JS :(. In those cases prevent them from making Emacs
slow:

#+BEGIN_SRC emacs-lisp
  (global-so-long-mode t)
#+END_SRC

** Whitespace

Cleanup whitespaces automatically on save.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup))
#+END_SRC

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with. Better
use =smart-parens= to manage them. However the command name use words from an
arcane language :(, so I put together a table of human-readable description of
the commands. All key bindings are started with =M-s=.

| Bindings  | Command                | Description                                         |
|-----------+------------------------+-----------------------------------------------------|
| =DEL=     | =sp-splice-sexp=       | Delete surrounding pair                             |
| =M-S=     | =sp-rewrap-sexp=       | Replace the surrounding pair                        |
| =<right>= | =sp-slurp-hybrid-sexp= | Extend the pair to include items to the right       |
| =<left>=  | =sp-forward-barf-sexp= | Shrink the pair, the right-most item is put outside |

NOTE: This package is huge, I'm still learning it.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smartparens
    :ensure t
    :delight smartparens-mode
    :hook ((prog-mode . smartparens-mode))
    :bind (("M-s DEL" . sp-splice-sexp)
           ("M-S" . sp-rewrap-sexp)
           ("M-s <right>" . sp-slurp-hybrid-sexp)
           ("C-S-f" . sp-slurp-hybrid-sexp)
           ("M-s <left>" . sp-forward-barf-sexp)
           ("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("M-K" . sp-kill-sexp)
           ("M-]" . sp-select-next-thing))
    :config
    (sp-pair "{" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" nil
             :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :hook (after-init . show-paren-mode)
    :custom (show-paren-delay 0))

  (use-package elec-pair
    :hook (after-init . electric-pair-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package expand-region
    :ensure t
    :bind ("M--" . er/expand-region))

  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)

  (use-package delsel
    :hook (after-init . delete-selection-mode))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :delight yas-minor-mode
    :hook (after-init . yas-global-mode)
    :config
    (setq yas-prompt-functions
          '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
          yas-verbosity 1)

    ;; I'm an old Emacs hacker, I like the abbrev-way and bind yas-expand SPC
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    (unbind-key "TAB" yas-minor-mode-map)
    (unbind-key "<tab>" yas-minor-mode-map))
#+END_SRC

** Alignment

#+BEGIN_SRC emacs-lisp
  (use-package align
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode web-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1))))
#+END_SRC

** Diff

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally))
#+END_SRC


* Shell and remote

#+begin_src emacs-lisp
  (use-package comint
    :bind* ("C-c C-l" . comint-clear-buffer))
#+end_src

** EShell

#+BEGIN_SRC emacs-lisp
  (use-package eshell-toggle
    :ensure t
    :bind* (("C-c C-s" . eshell-toggle))
    :custom
    (eshell-toggle-use-git-root t))

  (use-package eshell-up
    :ensure t
    :defer t)

  (use-package eshell-z
    :ensure t
    :defer t)

  (use-package eshell
    :defer t
    :config
    (eval-and-compile
      (require 'eshell-up)
      (require 'eshell-z)
      ;;(require 'eshell-git-prompt)

      (defun td/eshell-pwd ()
        (replace-regexp-in-string
         (regexp-quote (expand-file-name "~"))
         "~"
         (eshell/pwd)))

      (defun td/eshell-prompt ()
        (format
         "\n%s@%s in %s\n%s "
         (propertize user-login-name 'face '(:foreground "#dc322f"))
         (propertize (or (getenv "HOST") (system-name)) 'face '(:foreground "#b58900"))
         (propertize (td/eshell-pwd) 'face '(:foreground "#859900"))
         (if (= (user-uid) 0)
             (propertize "#" 'face '(:foreground "red")) "$")
         ;;(eshell-git-prompt-robbyrussell)
         ))

      (defalias 'eshell/e 'find-file)

      (defun eshell/open (args)
        (interactive)
        (shell-command
         (concat (cl-case system-type
                   ((darwin) "open")
                   ((windows-nt) "start")
                   (t "xdg-open"))
                 (format " %s" args))))

      ;; (require 'eshell-dotenv)
      ;; (add-hook 'eshell-directory-change-hook #'eshell-dotenv-update 100)

      (setq eshell-prompt-function #'td/eshell-prompt
            eshell-prompt-regexp "^[^#$\\n]*[#$] "
            eshell-highlight-prompt nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package with-editor
    :ensure t
    :hook ((term-exec . with-editor-export-editor)
           (shell-mode . with-editor-export-editor)
           (eshell-mode . with-editor-export-editor)))
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :config
    (eval-and-compile
      (setq password-cache-expiry nil
            ;; tramp-debug-buffer t
            tramp-default-method "scp"
            tramp-verbose 1)

      (add-to-list 'auth-sources "~/Projects/dotfiles/dotfiles/.emacs.d/authinfo.gpg")
      (add-to-list 'auth-sources 'macos-keychain-generic t)
      (setq ange-ftp-netrc-filename "~/Projects/dotfiles/dotfiles/.emacs.d/authinfo.gpg")))
#+END_SRC

Some speedup for Tramp:

#+begin_src emacs-lisp
  (use-package vc
    :custom
    (vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
    (vc-follow-symlinks t)
    (vc-handled-backends '(Git)))
#+end_src


* Programming

#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :hook ((web-mode . eglot)
           (tuareg-mode . eglot)
           (js-mode . eglot)
           (js-jsx-mode . eglot)
           (typescript-mode . eglot)
           (reason-mode .eglot))
    :config
    (add-to-list 'eglot-server-programs '(web-mode . ("typescript-language-server" "--stdio"))))
#+end_src

#+begin_src emacs-lisp
  (defun td/eldoc-select-doc-buffer (_doc interactive)
    (when interactive
    (run-at-time 0.1 nil #'pop-to-buffer "*eldoc*")))

  (use-package eldoc
    :bind ("C-h C-h" . eldoc-print-current-symbol-info)
    :config
    (global-eldoc-mode -1)
    (setq eldoc-display-functions '(eldoc-display-in-buffer))
    (advice-add 'eldoc-display-in-buffer :after #'td/eldoc-select-doc-buffer))
#+end_src

#+begin_src emacs-lisp :tangle no
  (defun td/maybe-enable-lsp ()
    (interactive)
    (when (string-suffix-p "sx" (buffer-file-name))
      (lsp)))

  (use-package lsp-mode
    :ensure t
    :hook ((python-mode . lsp)
           (js-mode . lsp)
           (typescript-mode . lsp)
           (haskell-mode . lsp)
           (web-mode . td/maybe-enable-lsp)
           (tuareg-mode . lsp)
           (reason-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :commands lsp
    :custom
    (lsp-keymap-prefix "C-l")
    (lsp-prefer-capf t)
    (lsp-enable-file-watchers nil)
    (lsp-enable-indentation nil)
    (lsp-signature-auto-activate nil)
    (lsp-modeline-code-actions-enable nil)
    (lsp-headerline-breadcrumb-enable nil))

  (use-package consult-lsp
    :ensure t
    :bind (("M-g e" . consult-lsp-diagnostics)
           ("M-g i" . consult-lsp-symbols)))
#+end_src

** Auto completion

I use auto completion sparingly. Mostly because many of the programing
language support package use =company= for some of their functionalities. To
be fair, I'd like these mode to support Emacs's standard
=completion-at-point-functions= interface.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight company-mode
    :bind (("M-/" . company-manual-begin)
           ("C-x C-p" . company-files)
           :map company-active-map
           ("<tab>" . company-complete-common-or-cycle)
           ("C-n" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort))
    :hook (after-init . global-company-mode)
    :config
    (require 'company-dabbrev)

    (setq company-minimum-prefix-length 2
          company-require-match #'company-explicit-action-p
          company-show-numbers t
          company-idle-delay nil
          company-tooltip-align-annotations t
          company-backends
          '(company-capf company-dabbrev-code company-dabbrev company-keywords)
          company-dabbrev-other-buffers t
          company-dabbrev-char-regexp nil
          company-dabbrev-downcase nil))

  (use-package company-buffer-line
    :commands (company-same-mode-buffer-lines)
    :bind ("C-x C-l" . company-same-mode-buffer-lines))

  (use-package company-prescient
    :ensure t
    :hook (after-init . company-prescient-mode))
#+END_SRC

** Error checking

Flymake have a rewrite in Emacs 26.1. I'm giving it a try now

#+BEGIN_SRC emacs-lisp
  (defun flymake-proc-create-temp-in-tmp (file-name)
    (concat temporary-file-directory file-name))

  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error))
    :config
    (advice-add
     'flymake-proc-create-temp-inplace
     :filter-return #'flymake-proc-create-temp-in-tmp))
#+END_SRC

#+begin_src emacs-lisp :tangle no
  (use-package flycheck
    :ensure t
    :hook (after-init . global-flycheck-mode)
    :custom
    (flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x p v" . magit)
    :custom
    (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1))
#+END_SRC

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+BEGIN_SRC emacs-lisp
  (use-package compile
    :bind ("C-c m" . recompile)
    :hook (compilation-filter . td/colorize-compilation-buffer)
    :custom
    (compilation-ask-about-save nil)
    (compilation-scroll-output 'first-error)
    :config
    (require 'ansi-color)
    (defun td/colorize-compilation-buffer ()
      (read-only-mode -1)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode t)))
#+END_SRC

** Code folding

#+BEGIN_SRC emacs-lisp :tangle no
  (define-fringe-bitmap 'hideshow-fringe-marker [255] nil 16 '(top t))

  (defun td/hideshow-set-up-overlay (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put
       ov 'before-string (propertize "|" 'display '(left-fringe hideshow-fringe-marker)))
      (overlay-put
       ov 'display (propertize " …" 'face 'font-lock-comment-face))))

  (use-package hideshow
    :hook (prog-mode . hs-minor-mode)
    :custom
    (hs-hide-comments-when-hiding-all nil)
    (hs-set-up-overlay #'td/hideshow-set-up-overlay))

  (use-package hideshow-org
    :ensure t
    :hook (hs-minor-mode . hs-org/minor-mode))
#+END_SRC

** Web Development

Not programming per-se. I use =web-mode= for all my templating-related
editing, including PHP, since I rarely write PHP anymore.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html" . web-mode)
           ("\\.jsx" . web-mode)
           ("\\.tsx" . web-mode)
           ("\\.tpl" . web-mode)
           ("\\.erb" . web-mode)
           ("\\.tag" . web-mode)
           ("\\.eml" . web-mode)
           ("\\.php" . web-mode)
           ("\\.hbs" . web-mode)
           ("\\.mustache" . web-mode))
    :custom
    (web-mode-markup-indent-offset 2)
    (web-mode-css-indent-offset 2)
    (web-mode-code-indent-offset 2)
    (web-mode-script-padding 2)
    (web-mode-style-padding 2)
    (web-mode-enable-auto-quoting nil)
    (web-mode-enable-comment-annotation t))
#+END_SRC

Also, I can't live without Emmet.

#+BEGIN_SRC emacs-lisp
  (defun td/emmet-jsx-mode ()
    (interactive)
    (when (string-suffix-p "sx" (buffer-file-name))
      (setq-local emmet-expand-jsx-className? t)))

  (use-package emmet-mode
    :ensure t
    :delight emmet-mode
    :hook ((sgml-mode . emmet-mode)
           (css-mode . emmet-mode)
           (reason-mode . emmet-mode)
           (web-mode . emmet-mode)
           (js-mode . emmet-mode))
    :config
    (setq emmet-indentation 2
          emmet-preview-default nil
          emmet-insert-flash-time 0.1)

    (add-hook 'emmet-mode-hook #'td/emmet-jsx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css\\'"
    :config
    (setq css-indent-offset 2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook (css-mode . rainbow-mode))
#+END_SRC

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try.

#+BEGIN_SRC emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . js-mode))
    :config
    (setq js-indent-level 2
          js-indent-first-init 'dynamic
          js-switch-indent-offset 2
          js-enabled-frameworks '(javascript)))
#+END_SRC

#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode (("\\.ts$" . typescript-mode))
    :config
    (setq typescript-indent-level 2))
#+end_src

** Python

#+BEGIN_SRC emacs-lisp :tangle no
  (defun td/lsp-python ()
    (require 'lsp-python-ms)
    (lsp))

  (use-package lsp-python-ms
    :ensure t
    :hook (python-mode . td/lsp-python))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package py-isort
    :ensure t
    :defer t
    :functions py-isort-before-save)

  (use-package python
    :mode (("\\.py\\'" . python-mode))
    ;; :hook (before-save . py-isort-before-save)
    :config
    (setq python-fill-docstring-style 'django))
#+END_SRC

** Haskell

I'm also a Haskell beginner :). Setting up Haskell with Emacs is relatively
easy. There's also a catch-all IDE-like mode called =intero=, by the very
same folk who runs =stack=.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :mode (("\\.hs\\'" . haskell-mode))
    :bind (([remap haskell-mode-format-imports] . haskell-sort-imports))
    :custom
    (haskell-program-name "stack repl"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-haskell
    :ensure t
    ;; :custom
    ;; (lsp-haskell-server-path "~/.cabal/bin/ghcide")
    ;; (lsp-haskell-server-args '())
    )
#+END_SRC

** OCaml

I'm a Python veteran. When I have the opportunity to, I tried to use
Haskell. Recently I have been looking into OCaml, it seems like a very good,
practical choice.

The following are the issues I have working in Python and Haskell, they are the
reason I'm considering OCaml as my main language. Hopefully I'll get a better
experience with OCaml. Besides the fact that OCaml is strongly-typed and can be
used for both the web and server, following are my bad experiences with either
Python or Haskell:

1. Python:
   - No good package manager: poetry used to be the silver bullet, combining
     =pyenv= and =pipenv=, while also fixing their issues. For what it's worth,
     Poetry is miles better than the previous solutions, yet it still suffers
     from problems that are unbearable for me.
   - The lack of types. That alone is a serious drawback for me. Sure I can add
     type annotations and use mypy, but unless libraries are also shipped with
     type definitions, those provides very limited guarantee, which defeats the
     purpose of having types in the first place.
   - Library breaking changes: cryptonite changed and broke my code producing
     APNS push packages. It can't be detected until it's shipped to production,
     so it's really bad.

 2. Haskell
   - Stack breaks.
   - The compiler is slow, and there's no good story regarding cross-compile. My
     guess is that the runtime is so sophisticated that it has to be linked to
     at least libc, hence making producing static binaries much harder.
   - Lack of production oriented library/framework. It's kind of like with
     Clojure, the libraries are there and they are excellent, but there is no
     standard bundle requiring a lot of wiring setting up a project. OCaml has Sihl.
   - I was told that OCaml is worse than Haskell regarding libraries, but in my
     experience that is not true. OCaml might have less libraries, but they are
     much more comprehensive and well-maintained. A lot of the libraries in the
     Haskell world seems to be a one-off experiment, or an one-time job then
     abandoned at best. (I'm talking about iCalendar, and there are many other cases).

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t)

  (use-package reason-mode
    :ensure t)

  (use-package dune
    :ensure t)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-ocaml
    :custom
    (lsp-ocaml-lang-server-command '("ocamllsp", "--stdio")))
#+end_src

** Java
** Docker

I use Docker for almost every project now, it is useful even just for setting up
consistent development environment across the team. I use =docker= package to
manage Docker images and containers.

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode ("Dockerfile$" . dockerfile-mode))
#+END_SRC

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t
    :mode (("\\.tf" . terraform-mode)))

  (use-package terraform-doc
    :ensure t)
#+end_src

** SQL

#+begin_src emacs-lisp
  (use-package sqlformat
    :ensure t)

  (use-package sql
    :custom
    (sql-postgres-login-params
     '((user :default "postgres")
       (database :default "postgres")
       (server :default "localhost")
       (port :default 5432))))
#+end_src

** Misc

These are supports for other stuffs that I used:

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode))
    :config
    ;; Requires 'pip3 install --user markdown'
    (setq markdown-command "python3 -m markdown -x extra"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode
    :ensure t
    :mode (".*nginx.*\\.conf$" . nginx-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode)
           ("\\.sls$" . yaml-mode)
           ("^master$" . yaml-mode)
           ("^roster$" . yaml-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package feature-mode
    :ensure t
    :mode (("\\.feature$" . markdown-mode)))
#+END_SRC


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time logging

#+BEGIN_SRC emacs-lisp
  (use-package ob-async
    :ensure t
    :config
    (require 'ob-async))

  (use-package org
    :hook ((org-mode . org-indent-mode))
    :delight org-indent-mode
    :custom
    (org-directory "~/Desktop/")
    (org-default-notes-file (expand-file-name "inbox.org" org-directory))
    (org-agenda-files `(,org-directory))
    (org-agenda-skip-unavailable-files t)
    (org-hide-leading-stars t)
    (org-clock-persist 'history)
    (org-refile-targets '(("~/Desktop/archive.org" . (:level . 1))))
    (org-startup-with-inline-images t)
    (org-todo-keywords
     '((sequence "TODO(t@)" "WAITING(w@)" "|" "DONE(d@/!)" "CANCELED(c@)")))
    (org-src-fontify-natively t)

    :config
    (org-clock-persistence-insinuate)

    (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (http . t)
         (graphql . t)
         (python . t)
         (shell . t)
         (sql . t))))
#+END_SRC

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/canceled)
- But don't have any todo items

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :config
    (setq org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-stuck-projects
          '("+project+LEVEL=1/-WAITING-DONE-CANCELED" ("TODO" "WAITING") nil "")))
#+END_SRC

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

#+begin_src emacs-lisp
  (use-package org-capture
    :bind* (("C-c o c" . org-capture))
    :custom
    (org-capture-templates
     `(("t" "Inbox item" entry
        (file+headline "~/Desktop/inbox.org" "Inbox") nil)
       ("l" "TIL" entry
        (file+olp+datetree "~/Desktop/inbox.org" "TIL") nil
        :jump-to-captured t)
       ("b" "Blog" entry
        (file+olp+datetree "~/Desktop/inbox.org" "Blog") nil
        :jump-to-captured t))))
#+end_src

** Literate programming

Org Babel for literate programming and API documentation.

#+BEGIN_SRC emacs-lisp
  (use-package ob-core
    :defer t
    :hook (org-babel-after-execute . org-display-inline-images)
    :custom
    (org-confirm-babel-evaluate nil))

  (use-package ob-http
    :defer t
    :ensure t)

  (use-package ob-graphql
    :defer t
    :ensure t)
#+END_SRC

** Spell checking

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :bind ("s-i" . ispell-word)
    :config
    (setq ispell-program-name "aspell"
          ispell-extra-args
          '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary")
          ispell-skip-html t
          ispell-silently-savep t
          ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :delight flyspell-mode
    :hook (org-mode . flyspell-mode))
#+END_SRC


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        visible-bell nil
        ring-bell-function 'ignore
        scroll-preserve-screen-position t
        scroll-margin 8)
#+END_SRC

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+BEGIN_SRC emacs-lisp
  (setq-default
   fringes-outside-margins t
   ;; line-spacing 4
   default-frame-alist
   `((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     (ns-appearance . dark)
     ;; (font . "Monaco 14")
     ;; (font . "Menlo 14")
     ;; (font . "SF Mono 14")
     ;; (font . "Source Code Pro 14")
     (font . "JetBrains Mono 14")
     ;; (font . "Cascadia Mono 14")
     ;; (font . "Fira Mono 14")
     (top . 0) (left . 480)
     ;; (width . 96) (height . 96)
     (fullscreen . maximized)
     (vertical-scroll-bars . nil)
     (tool-bar-lines . 0)))

  (blink-cursor-mode -1)
  (load-theme 'deeper-blue)
#+END_SRC

#+begin_src emacs-lisp
  (use-package hl-line
    :hook (prog-mode . hl-line-mode))
#+end_src

Enable ligatures, only available in railwaycat Mac port.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'mac-auto-operator-composition-mode)
    (mac-auto-operator-composition-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-use-native-fullscreen t)
#+END_SRC

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :hook (after-init . sml/setup)
    :custom
    (sml/theme 'dark))
#+end_src

Truncate lines:

#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(vertical-border ((t (:foreground "#000" :background "#000"))))
   '(font-lock-comment-face ((t (:slant normal))))
   '(font-lock-comment-delimiter-face ((t (:slant normal))))
   '(font-lock-string-face ((t (:slant normal))))
   '(font-lock-constant-face ((t (:slant normal))))

   '(fringe ((t (:background nil))))
   '(line-number ((t :foreground nil :inherit font-lock-comment-face)))

   '(hl-line ((t :foreground nil :background "#323850")))

   '(markdown-inline-code-face ((t (:slant normal))))

   '(indent-guide-face ((t (:inherit font-lock-comment-face))))
   '(web-mode-variable-name-face ((t (:inherit default))))

   '(diff-hl-insert ((t (:inherit nil :background nil :foreground "#81af34"))))
   '(diff-hl-delete ((t (:inherit nil :background nil :foreground "#ff0000"))))
   '(diff-hl-change ((t (:inherit nil :background nil :foreground "#deae3e")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :ensure t
    :defer t
    :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (setq-default display-line-numbers-width 3)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'web-mode-hook #'display-line-numbers-mode)
#+END_SRC

The default line continuation indicator is too standout and distracting for me.

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b01000000
     #b10000000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) 'halftone)
  (setcdr (assq 'truncation fringe-indicator-alist) 'halftone)
#+END_SRC

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indentation
    :ensure t
    :delight highlight-indentation-current-column-mode
    :hook ((python-mode . highlight-indentation-current-column-mode)
           (yaml-mode . highlight-indentation-current-column-mode)
           (purescript-mode . highlight-indentation-current-column-mode)
           (haskell-mode . highlight-indentation-current-column-mode)))
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (eval-and-compile
      (setq rainbow-delimiters-max-face-count 1)

      (custom-theme-set-faces
       'user
       '(rainbow-delimiters-unmatched-face ((t (:inherit error :background "#f00")))))))
#+END_SRC

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package diff-hl
    :defer t
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :init
    (eval-and-compile
      (define-fringe-bitmap 'td/diff-hl-bmp [#b11110000] 1 8 '(top t))
      (defun td/diff-hl-bmp-fn (type pos) 'td/diff-hl-bmp)

      (setq diff-hl-draw-borders nil
            ;diff-hl-side 'right
            diff-hl-fringe-bmp-function #'td/diff-hl-bmp-fn)

      (defun diff-hl-overlay-modified (ov after-p beg end &optional len)
        "Markers disappear and reapear is kind of annoying to me.")))
#+END_SRC

#+begin_src emacs-lisp
    (defun td/adapt-font-size (&optional frame)
      (let* ((attrs (frame-monitor-attributes frame))
             (size (alist-get 'mm-size attrs))
             (geometry (alist-get 'geometry attrs))
             (ppi (/ (caddr geometry) (/ (car size) 25.4))))
        ;;(message "PPI: %s" ppi)
        (if (> ppi 120)
            (set-face-attribute 'default frame :height 150)
          (set-face-attribute 'default frame :height 140))))

    (add-function :after after-focus-change-function #'td/adapt-font-size)
    (add-hook 'after-make-frame-functions #'td/adapt-font-size)
#+end_src


* Misc

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :defer t
    :config
    (setq dired-recursive-deletes 'always))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Microsoft Edge Dev\" to reload active tab of window 1'"))

  (bind-key* "C-M-r" #'td/refresh-front-most-tab)
#+END_SRC


* Ideas

** Misc.
- https://github.com/raxod502/radian/blob/develop/emacs/radian.el#L3210


* Init file generation

Where the magic happen!

#+BEGIN_SRC text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.config/emacs/init.el")) nil t)
  # End:
#+END_SRC
