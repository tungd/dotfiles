#+title: Tung Dao's Emacs Setup
#+startup: overview
#+property: header-args :tangle "~/.config/emacs/init.el" :results silent

So, as an effort to improve the responsiveness, I'm going to reboot my Emacs
configuration. Hope it is better this time.

The idea is that I'm going to add things in, bit by bit, just enough to get it
going. This way I will be able to nail down the packages that cause issue, and
look for alternatives.

* Enable Lexical Binding

Make things a little bit faster. For context: https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding

#+begin_src emacs-lisp
  ;; -*- lexical-binding:t -*-
#+end_src

* Packages and initialization

All the packages I used are from [[https://melpa.org][MELPA]]. However, I install them automatically
with =use-package.el= instead of using =package.el= directly. Since Emacs 29.1,
=use-package.el= has been bundled with Emacs.

Also, Emacs 29.1 added the =package-vc-install= command, which is really handy as
quite a few of the packages I used are not available on MELPA yet.

#+begin_src emacs-lisp
  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    :custom
    (package-quickstart t))
#+end_src

#+begin_src emacs-lisp
  (setopt custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+end_src

#+begin_src emacs-lisp
  (use-package bind-key
    :functions (override-global-mode bind-key--remove)
    :hook (after-init . override-global-mode))
#+end_src

Sometimes I write my own package, or download package from Emacs wiki; they
are stored in the =~/.emacs.d/vendor= directory.

#+begin_src emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "vendor/"))
#+end_src


* Defaults

Personal information that some package use:

#+begin_src emacs-lisp
  (setopt user-full-name "Tung Dao"
          user-mail-address "me@tungdao.com"
          default-input-method "vietnamese-telex")
  (defvar personal-keybindings nil)
#+end_src

Less verbose choice:

#+begin_src emacs-lisp
  (setopt use-short-answers t)
#+end_src

Sane, modern defaults:

- clean minimal UI
- no unnecessary temporary files (I do keep backup files, but not auto-save
  and lock files)

#+begin_src emacs-lisp
  (setopt auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))
        backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil
        remote-file-name-inhibit-locks t)
#+end_src

Performance stuffs, I'm not sure how relevant these are, since I've moved to =nativecomp=.

#+begin_src emacs-lisp
  (setq-default
   bidi-display-reordering nil
   bidi-paragraph-direction 'left-to-right
   bidi-inhibit-bpa t)

  (setopt read-process-output-max (* 16 1024 1024)
        inhibit-compacting-font-caches t)
#+end_src

#+begin_src emacs-lisp
  (savehist-mode t)
#+end_src

#+begin_src emacs-lisp
  (setopt echo-keystrokes 0.02)
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :hook (after-init . which-key-mode)
    :custom
    (which-key-show-early-on-C-h t)
    (which-key-idle-delay most-positive-fixnum)
    (which-key-idle-secondary-delay 1e-100))
#+end_src

#+begin_src emacs-lisp
  (setopt enable-recursive-minibuffers t)
#+end_src

#+begin_src emacs-lisp
  (use-package desktop
    :hook ((after-init . desktop-save-mode)
           (after-init . desktop-read)))
#+end_src

#+begin_src emacs-lisp
  (use-package midnight
    :hook (after-init . midnight-mode))
#+end_src

** Server

#+begin_src emacs-lisp
  (use-package server
    :hook (after-init . server-start))
#+end_src


** MacOS specific stuffs

#+begin_src emacs-lisp
  (if (boundp 'ns-command-modifier)
      (setopt ns-command-modifier 'meta))
  (if (boundp 'ns-option-modifier)
      (setopt ns-option-modifier 'super))
  (if (boundp 'ns-use-native-fullscreen)
      (setopt ns-use-native-fullscreen t))

  (setopt trash-directory "~/.Trash"
        delete-by-moving-to-trash t)
#+end_src


* Navigation

** File position

#+begin_src emacs-lisp
  (use-package saveplace
    :hook (after-init . save-place-mode))
#+end_src

** Projects

#+begin_src emacs-lisp
  (use-package files
    :custom
    (remote-file-name-access-timeout 5))
#+end_src

Emacs built-in =project.el= has gone a long way so I'm using that now. There are
still some missing features coming from =projectile=, but I can live with that.

#+begin_src emacs-lisp
  (use-package project
    :commands (project-find-file project-vc-dir project-current)
    :custom
    (project-file-history-behavior 'relativize))
#+end_src

#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :bind ("C-c s" . rg-menu))
#+end_src

** Workspace

Perspective.el is nice, especially the narrowed down buffer list, however
Burly's killer feature is that it can restores windows that are not pointing to
buffers, .ie Eshell.


** Symbols

I used to use =dumb-jumb=, but LSP has gotten good enough and it supported all
of the languages that I use, so now I use the built-in =xref= and rely on LSP's
=xref= integration.

Default key bindings is

| Binding   | Command                              | Description |
|-----------+--------------------------------------+-------------|
| =M-.=     | =xref-find-definitions=              |             |
| =C-M-p=   | =xref-find-definitions-other-window= |             |
| =C-M-g=   | =xref-pop-marker-stack=              |             |

#+begin_src emacs-lisp
  (use-package grep
    :custom
    (grep-command "rg -nS --no-heading ")
    (grep-use-null-device nil))

  (use-package xref
    :bind (("C-M-p" . xref-find-definitions-other-window)
           ("C-M-g" . xref-go-back))
    :hook ((xref-after-update . outline-minor-mode))
    :custom
    (xref-search-program 'ripgrep))
#+end_src

** Mini-buffer

Shortcut key to go back to the home directory, works regardless of the
mini-buffer completion framework.

#+begin_src emacs-lisp
  (ido-mode -1)

  (use-package minibuffer
    :custom
    (minibuffer-visible-completions t)
    (completion-auto-help 'always)
    (completion-show-help nil)
    (completion-auto-select 'second-tab)
    (completions-max-height 20)
    (completions-sort 'historical)
    (completions-format 'one-column)
    (completions-detailed t)
    (completions-group t))

  (defun td/minibuffer-smart-tilde ()
    (interactive)
    (if (not (looking-back "/" 0))
        (call-interactively 'self-insert-command)
      (beginning-of-line)
      (kill-line)
      (insert "~/")))

  (bind-key "~" #'td/minibuffer-smart-tilde minibuffer-local-map)
  (bind-key "<s-backspace>" #'backward-kill-word minibuffer-local-map)
  (bind-key "TAB" #'minibuffer-complete minibuffer-mode-map)

  ;(bind-key "C-p" #'minibuffer-previous-completion minibuffer-local-map)
  ;(bind-key "C-n" #'minibuffer-next-completion minibuffer-local-map)

  ;(bind-key "C-p" #'minibuffer-previous-completion completion-in-region-mode-map)
  ;(bind-key "C-n" #'minibuffer-next-completion completion-in-region-mode-map)
#+end_src

Vertico is the next in line for vertical completion.

#+begin_src emacs-lisp :tangle no
  (use-package vertico
    :ensure t
    :hook (after-init . vertico-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-M-l" . consult-line)
           ("C-M-j" . consult-buffer)
           ("M-g b" . consult-bookmark)
           ("M-g y" . consult-yank-from-kill-ring)
           ("M-g t" . consult-theme)
           ("M-g m" . consult-mode-command)
           ;("M-g r" . consult-ripgrep)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap imenu] . consult-imenu))
    :custom
    (consult-narrow-key (kbd "<"))
    (consult-project-root-function #'vc-root-dir)
    (consult-preview-key nil)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))

  (use-package consult-flymake
    :bind ("M-g e" . consult-flymake))
#+end_src

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 128)
    :config
    (add-to-list 'recentf-exclude "elpa/.*")
    (add-to-list 'recentf-exclude "__init__.py")
    (add-to-list 'recentf-exclude "_build/*")
    (add-to-list 'recentf-exclude "node_modules/.*"))
#+end_src

#+begin_src emacs-lisp
  (bind-key* "C-;" #'execute-extended-command)
  (global-set-key (kbd "C-l") ctl-x-map)
#+end_src

#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :custom
    (avy-background t)
    :config
    (bind-key* "C-'" 'avy-goto-char))
#+end_src

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setopt orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setopt completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Bookmark

#+begin_src emacs-lisp
  (use-package bookmark
    :custom
    (bookmark-save-flag 1))
#+end_src


* Window Management

Temporary "focus" on a buffer by maximizing it in the current frame.

#+begin_src emacs-lisp
  (defun td/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (bind-key* [remap delete-other-windows] #'td/toggle-maximize-buffer)
  (bind-key* "M-C-o" #'td/toggle-maximize-buffer)
  (bind-key* "M-o" #'other-window)
#+end_src

Buffer location customization

#+begin_src emacs-lisp
  (use-package window
    :custom
    (window-min-height 1)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\*compilation\\*" (display-buffer-reuse-window display-buffer-below-selected)
                   (inhibit-same-window . t)
                   (window-height . 16)))
    (add-to-list 'display-buffer-alist
                 '("\\*Warnings\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8)))
    (add-to-list 'display-buffer-alist
                 '("\\*Help\\*"
                   (display-buffer-reuse-window display-buffer-pop-up-window)
                   (inhibit-same-window . t)))
    (add-to-list 'display-buffer-alist
                 '("\\*Org-Babel Error Output\\*" display-buffer-in-direction
                   (direction . bottom)
                   (window-height . 8))))
#+end_src


* General Editing

#+begin_src emacs-lisp
  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package vundo :ensure t)
#+end_src

#+begin_src emacs-lisp
  (bind-key [remap zap-to-char] #'zap-up-to-char)
#+end_src

#+begin_src emacs-lisp
  (use-package misc
    :custom
    (duplicate-line-final-position -1)
    :bind*
    ("C-c C-d" . duplicate-dwim))
#+end_src

#+begin_src emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'forward))
#+end_src

#+begin_src emacs-lisp
  (use-package ibuffer
    :defer t
    :bind ([remap list-buffers] . ibuffer))
#+end_src

#+begin_src emacs-lisp
  (setopt kill-do-not-save-duplicates t)
#+end_src

Basic settings:

#+begin_src emacs-lisp
    (setq-default
     tab-width 2
     indent-tabs-mode nil
     reb-re-syntax 'string)
#+end_src

Editing utilities:

#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (;; There's a built-in `switch-to-prev-buffer', but it is less helpful
           ;; since it doesn't allow me to quickly switch between the most
           ;; recent buffers
           ("M-C-]" . crux-switch-to-previous-buffer)
           ("M-J" . join-line)
           ("M-=" . crux-cleanup-buffer-or-region)
           ("C-M-k" . crux-kill-whole-line)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c C-o" . crux-open-with)
           ([remap kill-line] . crux-smart-kill-line))
    :config
    ;(crux-with-region-or-buffer indent-region)
    ;(crux-with-region-or-buffer untabify)
    ;(crux-with-region-or-point-to-eol kill-ring-save)
    (setopt kill-do-not-save-duplicates t))

  (bind-key* "C-x C-k" #'kill-current-buffer)
  (bind-key* "C-c r" #'rename-visited-file)
  (bind-key* "s-n" #'next-buffer)
  (bind-key* "s-p" #'previous-buffer)
#+end_src

Make the file executable if starting with "shebang":

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Search and replace

#+begin_src emacs-lisp
  (use-package isearch
    :defer t
    :custom
    (isearch-wrap-pause 'no)
    (isearch-lazy-count t)
    (search-ring-max 256)
    (regexp-search-ring-max 200)
    :bind
    ([remap isearch-forward] . isearch-forward-regexp)
    ([remap isearch-backward] . isearch-backward-regexp))
#+end_src

#+begin_src emacs-lisp
  (use-package visual-replace
    :ensure t
    :bind (("M-r" . visual-replace)
           ([remap query-replace] . visual-replace)
           :map isearch-mode-map
           ("M-r" . visual-replace-from-isearch))
    :custom
    (visual-replace-default-to-full-scope t)
    (visual-replace-display-total t)
    (visual-replace-keep-initial-position t)
    :config
    (define-key visual-replace-mode-map (kbd "M-r")
                visual-replace-secondary-mode-map))
#+end_src

** Long lines

Long lines are annoying. Auto wrap all texts at 80.

#+begin_src emacs-lisp
  (use-package autorevert
    :hook (after-init . global-auto-revert-mode)
    :custom
    (auto-revert-avoid-polling t)
    (auto-revert-interval 5)
    (auto-revert-check-vc-info t))

  (setq-default
   comment-auto-fill-only-comments t
   fill-column 80)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+end_src

** Whitespace

Cleanup whitespaces automatically on save.

#+begin_src emacs-lisp
  (use-package whitespace
    :commands (whitespace-cleanup)
    :hook (before-save . whitespace-cleanup)
    :config
    ;; (setopt whitespace-style (remove 'newline-mark whitespace-style))
    )
#+end_src

** Parenthesis

Parenthesis come in pairs, that's why they are cumbersome to deal with.

#+begin_src emacs-lisp
  (use-package paren
    :hook (after-init . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-context-when-offscreen 'overlay))

  (use-package elec-pair
    :hook (after-init . electric-pair-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package surround
    :ensure t
    :bind-keymap ("M-s" . surround-keymap))
#+end_src

#+begin_src emacs-lisp
  (defun td/mark-line-dwim ()
    (interactive)
    (call-interactively #'beginning-of-line)
    (call-interactively #'set-mark-command)
    (call-interactively #'end-of-line))

  (bind-key "M-C-SPC" #'td/mark-line-dwim)

  (use-package delsel
    :hook (after-init . delete-selection-mode))
#+end_src

** Snippets

I've since switched to =Tempel= instead of =Yasnippet=. With Copilot, the
suggestions is my snippet/template. Coupled with Eglot/LSP for
function/method-based templates, I rarely need a library of
snippets/templates. For the occasional needs that is specific to me/my workflow,
a more minimal template library like =Tempo=/=Tempel= is suffice.

I settled with =Tempel=, it polished some of the rough edges with =Tempo=, namely:

- Per-language/major-mode templates. =Tempo= does support this in the form of
  tags, however it requires some glue code, while =Tempel= has built-in support
- Temporary key map for moving between placeholders/poi/marks

Since the template definition is compatible between the 2, I can easily move to
=Tempo= in the future if it added support for the 2 points above.

#+begin_src emacs-lisp
  (use-package tempel
    :ensure t
    :hook (after-init . global-tempel-abbrev-mode)
    :bind (("M-+" . tempel-complete)
           ("M-*" . tempel-insert)))
#+end_src

Tempo integration code for future reference:

#+begin_src emacs-lisp :tangle no
  (defun td/tempo-space-dwim ()
    (interactive "*")
    (or (tempo-expand-if-complete) (insert " ")))

  (defun td/tempo-forward-mark-dwim ()
    (interactive)
    (or (tempo-forward-mark) (forward-paragraph)))

  (use-package tempo
    :functions (tempo-define-template tempo-expand-if-complete)
    :bind (("M-+" . tempo-complete-tag)
           ("SPC" . td/tempo-space-dwim)
           ("M-}" . td/tempo-forward-mark-dwim))
    :custom
    (tempo-insert-region t)
    :init
    (tempo-define-template tempo-expand-if-complete)))
#+end_src

** Alignment

#+begin_src emacs-lisp
  (use-package align
    :bind (("C-c =" . align))
    :config
    (add-to-list 'align-rules-list
                 '(js-object-props
                   (modes . '(js-mode js2-mode js-ts-mode tsx-ts-mode))
                   (regexp . "\\(\\s-*\\):")
                   (spacing . 0)))
    (add-to-list 'align-rules-list
                 '(css-declaration
                   (modes . '(css-mode css-ts-mode))
                   (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")
                   (group 1)))
    (add-to-list 'align-rules-list
                 '(haskell-record-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\)::")
                   (spacing . 1)))
    (add-to-list 'align-rules-list
                 '(haskell-aeson-fields
                   (modes . '(haskell-mode))
                   (regexp . "\\(\\s-*\\).=")
                   (spacing . 1))))
#+end_src

** Diff

#+begin_src emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-keep-variants nil)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally))
#+end_src


* Shell and remote

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :hook (after-init . exec-path-from-shell-initialize))
#+end_src

#+begin_src emacs-lisp
  (use-package envrc
    :ensure t
    :hook (after-init . envrc-global-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package comint
    :bind ("C-c C-l" . comint-clear-buffer))
#+end_src


** Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :custom
    (tramp-allow-unsafe-temporary-files t)
    (tramp-default-method "ssh")
    :config
    (add-to-list 'auth-sources (expand-file-name "authinfo.gpg" user-emacs-directory))
    (add-to-list 'auth-sources 'macos-keychain-generic t)
    (add-to-list 'tramp-connection-properties '("/ssh:" "direct-async-process" t)))
#+end_src

Some speedup for Tramp:

#+begin_src emacs-lisp
  (use-package vc
    :custom
    (vc-follow-symlinks t)
    (vc-handled-backends '(Git)))
#+end_src


* Programming

Native LSP support via =Eglot= since Emacs 29.1

#+begin_src emacs-lisp
  (setopt read-process-output-max (* 8 1024 1024))

  (use-package eglot
    :hook ((js-ts-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure)
           (tsx-ts-mode . eglot-ensure)
           (go-ts-mode . eglot-ensure)
           (ocaml-ts-mode . eglot-ensure)
           (kotlin-ts-mode . eglot-ensure)
           (tuareg-mode . eglot-ensure))
    :bind ("C-c C-a" . eglot-code-actions)
    :custom
    (eglot-autoshutdown t)
    (eglot-prefer-plaintext t)
    (eglot-connect-timeout 300)
    (eglot-ignored-server-capabilities '(:documentFormattingProvider
                                         :documentRangeFormattingProvider
                                         :documentOnTypeFormattingProvider
                                         :documentHighlightProvider))
    (eglot-send-changes-idle-time 0.1)
    (eglot-extend-to-xref t)
    :config
    (add-to-list 'eglot-server-programs '(ocaml-ts-mode "ocamllsp"))
    (add-to-list 'eglot-server-programs '((web-mode :language-id "typescriptreact") "typescript-language-server" "--stdio"))
    ;; https://www.reddit.com/r/emacs/comments/17jrsmv/comment/k74b3tg/?utm_source=share&utm_medium=web2x&context=3
    (advice-add 'jsonrpc--log-event :override #'ignore))
#+end_src

#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (setopt eldoc-display-functions '(eldoc-display-in-buffer)))
#+end_src

Native Tree-sitter support since Emacs 29

#+begin_src emacs-lisp
  (defun td/treesit-mark-node (node)
    (goto-char (treesit-node-start node))
    (call-interactively #'set-mark-command)
    (goto-char (treesit-node-end node)))

  (defun td/tressit-expand-region ()
    "Poor man's expand-region, worked surprisingly well for me"
    (interactive)
    (let ((start (if (region-active-p) (region-beginning) 1))
          (end (if (region-active-p) (region-end) 1))
          (node (if (region-active-p)
                    (treesit-node-parent
                     (treesit-node-on (region-beginning) (region-end)))
                  (treesit-node-at (point)))))
      (if (or (/= start (treesit-node-start node))
              (/= end (treesit-node-end node)))
          (td/treesit-mark-node node)
        (forward-char)
        (td/tressit-expand-region))))

  (bind-key "M--" #'td/tressit-expand-region)

  (use-package treesit
    :functions (treesit-node-on
                treesit-node-at
                treesit-node-parent
                treesit-node-start
                treesit-node-end
                treesit-node-prev-sibling)
    :config
    (add-to-list 'treesit-language-source-alist '(kotlin . ("https://github.com/fwcd/tree-sitter-kotlin.git"))))

  (defun td/treesit-indent-debug (n p _bol)
    (message
     "treesit-indent-debug: %s %s %s"
     n p (treesit-node-prev-sibling n)))

  (defun td/treesit-tag-start (_n p _bol)
    (save-excursion
      (goto-char (treesit-node-start p))
      (search-forward "<")
      (- (point) 1)))

  (defun td/treesit-tag-sibling (n p bol)
    (when treesit--indent-verbose
      (td/treesit-indent-debug n p bol))
    (let* ((tag (treesit-parent-until
                 p
                 (rx (or "jsx_closing_element" "jsx_element" "jsx_self_closing_element"))))
           (prev (treesit-node-prev-sibling tag)))
      (when treesit--indent-verbose
        (message "tag: %s, prev: %s" tag prev))
      (cond
       ((treesit-node-match-p prev (rx "jsx_opening_element"))
        ;; This is the first child, need to check the parent tag
        (let ((parent-tag (treesit-parent-until tag "jsx_element")))
          (+ (td/treesit-tag-start tag parent-tag 0) typescript-ts-mode-indent-offset)))
       ((treesit-node-match-p tag (rx "jsx_closing_element"))
        (let ((parent-tag (treesit-parent-until tag "jsx_element")))
          (td/treesit-tag-start tag parent-tag 0)))
       (t (save-excursion
            (goto-char (treesit-node-start prev))
            (while (and (<= (point) (point-max))
                        (looking-at (rx (| whitespace control)) t))
              (forward-char))
            (point))))))

  (defvar td/tsx-additional-indent-rules
    '(((match nil "<") td/treesit-tag-sibling 0)
      ((parent-is "jsx_text") parent-bol 2)
      ((node-is "jsx_closing_element") td/treesit-tag-start 0)
      ((match "/" "jsx_self_closing_element") td/treesit-tag-start 0)
      ((match ">" "jsx_opening_element") td/treesit-tag-start 0)
      ((parent-is "jsx_opening_element") td/treesit-tag-start 2)
      ((parent-is "jsx_self_closing_element") td/treesit-tag-start 2)))

  (defun td/fix-tsx-indentation ()
    (setq-local
     treesit-simple-indent-rules
     (list (cons 'tsx (append td/tsx-additional-indent-rules (cdar (typescript-ts-mode--indent-rules 'tsx)))))))

  (use-package typescript-ts-mode
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode))
    :hook ((tsx-ts-mode . td/fix-tsx-indentation)))

  (use-package go-ts-mode
    :mode (("go.mod$" . go-mod-ts-mode)
           ("\\.go\\'" . go-ts-mode))
    :custom
    (go-ts-mode-indent-offset 2))

  (setopt
   major-mode-remap-alist
   '((js-mode . js-ts-mode)
     (typescript-mode . typescript-ts-mode)
     (json-mode . json-ts-mode)
     (css-mode . css-ts-mode)
     ;; (python-mode . python-ts-mode)
     ))
#+end_src

** Auto completion

I use auto completion sparingly.

#+begin_src emacs-lisp
  (use-package dabbrev
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . completion-at-point)))

  (defun td/expand-lines ()
    (interactive)
    (let ((hippie-expand-try-functions-list
           '(try-expand-line)))
      (call-interactively 'hippie-expand)))

  (bind-key "C-x C-l" #'td/expand-lines)
#+end_src

#+begin_src emacs-lisp
  (use-package copilot
    :vc (:url "https://github.com/copilot-emacs/copilot.el.git" :branch "main" :rev :newest)
    :ensure t
    :bind (:map copilot-completion-map ("C-j" . copilot-accept-completion))
    :hook ((mhtml-mode . copilot-mode)
           (css-ts-mode . copilot-mode)
           (html-ts-mode . copilot-mode)
           (js-ts-mode . copilot-mode)
           (typescript-ts-mode . copilot-mode)
           (tsx-ts-mode . copilot-mode)
           (kotlin-ts-mode . copilot-mode)
           (go-ts-mode . copilot-mode)
           (python-mode . copilot-mode))
    :config
    (add-to-list 'copilot-major-mode-alist '("tsx" . "typescriptreact")))
#+end_src

#+begin_src emacs-lisp
  (use-package gptel-anthropic
    :functions gptel-make-anthropic)
  (use-package gptel-org)
  (use-package gptel
    :ensure t
    :bind ("C-l c" . gptel-menu)
    :custom
    (gptel-model 'claude-3-5-sonnet-20241022)
    (gptel-default-mode 'org-mode)
    :config
    (setopt gptel-backend
            (gptel-make-anthropic
                "Claude"
              :stream t :key (auth-source-pick-first-password :host "claude" :max 1))))
#+end_src

** Error checking

#+begin_src emacs-lisp
  (use-package flymake
    :defer t
    :bind (:map flymake-mode-map
                ("C-c e n" . flymake-goto-next-error)
                ("C-c e p" . flymake-goto-prev-error)))
#+end_src

** Version Control

Git has won the version control war, everyone uses Git now. Emacs'
built-in VC has great support for git but Magit is godsend.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x p v" . magit)
    :custom
    (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
    (magit-show-long-lines-warning nil)
    :config
    (remove-hook 'server-switch-hook 'magit-commit-diff)
    (remove-hook 'with-editor-filter-visit-hook 'magit-commit-diff))
#+end_src

** Compile

I use =compile= not only for compilation but also as a generic method to run
repetitive tasks. For example, I to run unit tests repeatedly, I first run
=M-x compile= with the test commands. Subsequence =recompile= call will
re-run the tests.

#+begin_src emacs-lisp
  (use-package compile
    :bind ("C-c m" . recompile)
    :hook (compilation-filter . ansi-color-compilation-filter)
    :custom
    (compilation-ask-about-save nil)
    (compilation-scroll-output t))
#+end_src

** Code folding

TDB: waiting for folding support with Treesitter

** Web Development

#+begin_src emacs-lisp
  (defun td/format-html-attributes ()
    (interactive)
    (save-excursion
      (re-search-backward "<")
      (while (not (looking-at "[\n\r/]"))
        (re-search-forward "\s+[^=]+=")
        (goto-char (match-beginning 0))
        (newline-and-indent))))

  (bind-key "C-M-=" #'td/format-html-attributes)
#+end_src

#+begin_src emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook (mhtml-mode . emmet-mode)
    :bind ("C-M-<return>" . emmet-expand-line)
    :config
    (unbind-key "C-j" emmet-mode-keymap))
#+end_src

#+begin_src emacs-lisp
  (use-package sgml-mode
    :mode (("\\.svg" . sgml-mode)))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :mode ("\\.css\\'" . css-ts-mode)
    :custom
    (css-indent-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :hook ((css-mode . rainbow-mode)
           (css-ts-mode . rainbow-mode)))
#+end_src

** JavaScript

Like most people I used to use =js2-mode= for all my JavaScript editing,
including JSX. Since I'm no longer write as much JavaScript, and I will use
=es-lint= for syntax checking anyways, I think I'm going to give the built-in
=js-mode= a try.

#+begin_src emacs-lisp
  (use-package js
    :mode (("\\.eslintrc$" . json-ts-mode))
    :mode (("\\.mjs$" . js-ts-mode))
    :custom
    (js-indent-level 2)
    (js-indent-first-init 'dynamic)
    (js-switch-indent-offset 2)
    (js-enabled-frameworks '(javascript)))
#+end_src

** Python

** OCaml

I'm a Python veteran. When I have the opportunity to, I tried to use
Haskell. Recently I have been looking into OCaml, it seems like a very good,
practical choice.

The following are the issues I have working in Python and Haskell, they are the
reason I'm considering OCaml as my main language. Hopefully I'll get a better
experience with OCaml. Besides the fact that OCaml is strongly-typed and can be
used for both the web and server, following are my bad experiences with either
Python or Haskell:

1. Python:
   - No good package manager: poetry used to be the silver bullet, combining
     =pyenv= and =pipenv=, while also fixing their issues. For what it's worth,
     Poetry is miles better than the previous solutions, yet it still suffers
     from problems that are unbearable for me.
   - The lack of types. That alone is a serious drawback for me. Sure I can add
     type annotations and use mypy, but unless libraries are also shipped with
     type definitions, those provides very limited guarantee, which defeats the
     purpose of having types in the first place.
   - Library breaking changes: cryptonite changed and broke my code producing
     APNS push packages. It can't be detected until it's shipped to production,
     so it's really bad.

   2. Haskell
      - Stack breaks.
      - The compiler is slow, and there's no good story regarding cross-compile. My
        guess is that the runtime is so sophisticated that it has to be linked to
        at least libc, hence making producing static binaries much harder.
      - Lack of production oriented library/framework. It's kind of like with
        Clojure, the libraries are there and they are excellent, but there is no
        standard bundle requiring a lot of wiring setting up a project. OCaml has Sihl.
      - I was told that OCaml is worse than Haskell regarding libraries, but in my
        experience that is not true. OCaml might have less libraries, but they are
        much more comprehensive and well-maintained. A lot of the libraries in the
        Haskell world seems to be a one-off experiment, or an one-time job then
        abandoned at best. (I'm talking about iCalendar, and there are many other cases).

#+begin_src emacs-lisp :tangle no
  (use-package tuareg
    :ensure t)

  (use-package reason-mode
    :ensure t)
#+end_src

** Java

** Kotlin

#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :ensure t
    :mode (("\\.kt\\'" . kotlin-ts-mode)
           ("\\.kts\\'" . kotlin-ts-mode)))
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t
    :mode (("\\.tf" . terraform-mode))
    :custom (terraform-format-on-save t))
#+end_src

** SQL

#+begin_src emacs-lisp
  (use-package sql
    :custom
    (sql-postgres-login-params
     '((user :default "postgres")
       (database :default "postgres")
       (server :default "localhost")
       (port :default 5432))))
#+end_src

** Misc

These are supports for other stuffs that I used:

#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode (("\\.yaml$" . yaml-ts-mode))
    :hook (yaml-ts-mode . display-line-numbers-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package nix-ts-mode
    :ensure t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode)
           ("\\.markdown$" . markdown-mode))
    :custom
    ;; Requires 'pip3 install --user markdown'
    (markdown-command "python3 -m markdown -x extra"))
#+end_src


* Document and management

I use Org for almost everything. Blogging, task management, API documentation,
literate programming.

** Tracking and tasks management

I tried many management tools: Wunderlist, Todoist, Google Calendar
.etc. However all of them are missing something really crucial for me. For
example Wunderlist has agenda overview, but lacks adding note to
tasks. Evernote has execllent note support, but their project management is
just barebone, not much than a todo list.

Org on the other hand lacks notification and ubiquitous access. I'm looking
for a solution though.

Here's my basic Org setup:

- A default =inbox.org= on Desktop for tasks capturing and project management
- Nicer display with inline images
- Enable GTD todo keyword sequence and time logging

#+begin_src emacs-lisp
  (use-package ob-plantuml
    :custom
    (org-plantuml-jar-path "/opt/local/share/java/plantuml/plantuml.jar"))

  (defun td/org-electric-pair ()
    (setq-local
     electric-pair-inhibit-predicate
     `(lambda (c)
        (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))

  (use-package org
    :hook ((org-mode . org-indent-mode)
           (org-mode . td/org-electric-pair))
    :custom
    (org-directory "~/Documents/Journal")
    (org-default-notes-file (expand-file-name "inbox.org" org-directory))
    (org-agenda-files `(,org-directory))
    (org-agenda-skip-unavailable-files t)
    (org-hide-leading-stars t)
    (org-clock-persist 'history)
    ;; (org-refile-targets '(("~/Desktop/archive.org" . (:level . 1))))
    (org-startup-with-inline-images t)
    (org-todo-keywords
     '((sequence "TODO(t@)" "WAITING(w@)" "|" "DONE(d@/!)" "CANCELED(c@)")))
    (org-src-fontify-natively t)

    :config
    (require 'org-tempo)
    (org-clock-persistence-insinuate)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (http . t)
       (plantuml . t)
       (python . t)
       (shell . t)
       (js . t)
       (kotlin . t)
       (sql . t))))
#+end_src

Agenda overview and filtering. Org provides a bunch of quick overviews:

| Binding                | Description                                   |
|------------------------+-----------------------------------------------|
| =C-c o a t=, =C-c o t= | List the TODO items                           |
|------------------------+-----------------------------------------------|
| =C-c o a #=            | List stuck projects, see =org-stuck-projects= |
|------------------------+-----------------------------------------------|
| =C-c o a s=            | Search Org headers                            |

Stuck projects are:

- Top level outlines that have the tag =project=
- Without holding state (waiting/done/canceled)
- But don't have any todo items

#+begin_src emacs-lisp
  (use-package org-agenda
    :bind (("C-c o a" . org-agenda)
           ("C-c o t" . org-todo-list))
    :custom
    (org-agenda-restore-windows-after-quit t)
    (org-agenda-window-setup 'current-window)
    (org-stuck-projects
     '("+project+LEVEL=1/-WAITING-DONE-CANCELED" ("TODO" "WAITING") nil "")))
#+end_src

** Note taking

As stated earlier, I practice GTD. Working projects and new stuffs go to
=inbox.org= file. Old tasks are archived to =archive.org=. Here's my
=org-capture= templates to dump stuffs to =inbox/note=

#+begin_src emacs-lisp
  (use-package org-capture
    :bind* (("C-c o c" . org-capture))
    :custom
    (org-capture-templates
     `(("t" "Inbox item" entry
        (file+headline "~/Desktop/inbox.org" "Inbox") nil)
       ("l" "TIL" entry
        (file+olp+datetree "~/Desktop/inbox.org" "TIL") nil
        :jump-to-captured t)
       ("b" "Blog" entry
        (file+olp+datetree "~/Desktop/inbox.org" "Blog") nil
        :jump-to-captured t))))
#+end_src

** Literate programming

Org Babel for literate programming and API documentation.

#+begin_src emacs-lisp
  (use-package ob-core
    :defer t
    :hook (org-babel-after-execute . org-display-inline-images)
    :custom
    (org-confirm-babel-evaluate nil))

  (use-package ob-http
    :defer t
    :ensure t
    :custom
    (ob-http:max-time 180)
    (ob-http:remove-cr t))

  (use-package ob-python
    :defer t
    :custom
    (org-babel-python-command "python3.12"))
#+end_src

** Spell checking

#+begin_src emacs-lisp :tangle no
  (use-package ispell
    :bind ("s-i" . ispell-word)
    :custom
    (ispell-program-name "aspell")
    (ispell-extra-args
     '("--sug-mode=ultra" "--lang=en_US" "--personal=~/.emacs.d/dictionary"))
    (ispell-skip-html t)
    (ispell-silently-savep t)
    (ispell-really-aspell t))

  (use-package flyspell
    :defer t
    :hook (org-mode . flyspell-mode))
#+end_src


* Appearance

I love eye candy <3. I put quite a lot of efforts to make Emacs look
the way I liked.

#+begin_src emacs-lisp
  (setopt inhibit-startup-screen t
          visible-bell nil
          ring-bell-function 'ignore
          scroll-preserve-screen-position t
          scroll-margin 8
          scroll-conservatively 101
          auto-window-vscroll nil)

  (pixel-scroll-precision-mode t)
#+end_src

I use mouse scroll a lot, and with the default key binding it would accidentally
change the text scale. I don't want this behavior, hence unbind the key here.

#+begin_src emacs-lisp
  (unbind-key "C-<mouse-5>")
  (unbind-key "C-<mouse-4>")
  (unbind-key "C-<wheel-down>")
  (unbind-key "C-<wheel-up>")
#+end_src

Default window configuration: half-left of the screen, no scroll bars, no menu
bars, no cursor blinking. And btw, nothing beats the classic Monaco. "Menlo",
"Source Code Pro" and "Fira Code" come close, currently I have to use them for
bold and ligatures support :(.

#+begin_src emacs-lisp
  (setopt
   fringes-outside-margins t
   default-frame-alist
   `((left-fringe . 8) (right-fringe . 4)
     (border-width . 0) (internal-border-width . 0)
     (font . "Iosevka SS07 16")
     ;; (font . "JetBrains Mono NL 14")
     ;; (font . "Agave 16")
     ;; (font . "Ubuntu Mono 16")
     (tool-bar-lines . 0)
     (fullscreen . maximized)
     (ns-appearance . dark)
     (vertical-scroll-bars . nil)))

  (blink-cursor-mode -1)
  (tool-bar-mode -1)
  (setq-default cursor-in-non-selected-windows nil)

  (unless (display-graphic-p)
    (menu-bar-mode -1))
#+end_src

Hide unnecessary long mode line mode list

#+begin_src emacs-lisp
  (use-package minions :ensure t :hook (after-init . minions-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package hl-line :hook (after-init . global-hl-line-mode))
#+end_src

Truncate lines:

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indentation
    :ensure t
    :hook ((python-mode . highlight-indentation-mode)
           (yaml-mode . highlight-indentation-mode)
           (yaml-ts-mode . highlight-indentation-mode))
    :custom
    (highlight-indentation-blank-lines t))
#+end_src

Some preferences that I set for all the theme. Per documentation, the custom
theme named =user= will always have the highest priority.

#+begin_src emacs-lisp :tangle no
  (use-package doom-themes
    :ensure t
    :init (load-theme 'doom-ayu-mirage t))
#+end_src

#+begin_src emacs-lisp
  (load-theme 'modus-vivendi t)
#+end_src

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(font-lock-comment-face ((t :slant normal)))
   '(font-lock-comment-delimiter-face ((t :slant normal)))
   '(font-lock-string-face ((t :slant normal)))
   '(font-lock-constant-face ((t :slant normal)))

   '(line-number ((t :slant normal :foreground unspecified :inherit font-lock-comment-face)))
   '(line-number-current-line ((t :slant normal)))
   '(fringe ((t :inherit line-number :background unspecified)))
   ;;'(vertical-border ((t :foreground "#000")))

   ;;'(mode-line-buffer-id ((t :foreground "#deae3e")))
   ;;'(mode-line ((t :inherit line-number-current-line :foreground nil :background nil :box (:style 'flat))))
   ;;'(mode-line-inactive ((t :inherit line-number :background nil :foreground nil)))
   ;;'(cursor ((t :background "orange")))
   )
#+end_src

Line and column numbers, which I find only helpful when tracking
down compiler error :(.

#+begin_src emacs-lisp
  (column-number-mode t)
  (line-number-mode t)

  (use-package display-line-numbers
    :hook ((prog-mode . display-line-numbers-mode)
           (org-mode . display-line-numbers-mode)
           (yaml-mode . display-line-numbers-mode)
           (conf-mode . display-line-numbers-mode))
    :custom
    (display-line-numbers-width-start 100))
#+end_src

The default line continuation indicator is too standout and distracting for me.

#+begin_src emacs-lisp
  (define-fringe-bitmap 'halftone
    [#b10100000
     #b01010000]
    nil nil '(top t))

  (setcdr (assq 'continuation fringe-indicator-alist) '(nil halftone))
  (setcdr (assq 'truncation fringe-indicator-alist) '(nil halftone))
#+end_src

Display change marker based on =git=. I usually turn this off because it is
kind of distracting, but it is really helpful sometimes.

#+begin_src emacs-lisp
  (defun td/diff-hl-fringe-bmp (_type _pos) 'halftone)

  (defun td/diff-hl-overlay-modified (_ov _after-p _beg _end &optional _len)
    "No-op. Markers disappear and reapear is annoying to me.")

  (use-package diff-hl
    :ensure t
    :hook (after-init . global-diff-hl-mode)
    :custom
    (diff-hl-draw-borders nil)
    (diff-hl-fringe-bmp-function #'td/diff-hl-fringe-bmp)
    (diff-hl-disable-on-remote t)
    :config
    (custom-theme-set-faces
     'user
     '(diff-hl-insert ((t (:inherit nil :background unspecified :foreground "#81af34"))))
     '(diff-hl-delete ((t (:inherit nil :background unspecified :foreground "#ff0000"))))
     '(diff-hl-change ((t (:inherit nil :background unspecified :foreground "#deae3e")))))

    (advice-add 'diff-hl-overlay-modified :override #'td/diff-hl-overlay-modified))
#+end_src


* Misc

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    (dired-listing-switches "-lah")
    (dired-auto-revert-buffer t)
    (dired-kill-when-opening-new-dired-buffer t))
#+end_src

#+begin_src emacs-lisp
  (defun td/refresh-front-most-tab ()
    (interactive)
    (shell-command "osascript -e 'tell application \"Microsoft Edge\" to reload active tab of window 1'"))

  (bind-key* "C-M-r" #'td/refresh-front-most-tab)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package kubel
    :ensure t
    :defer t
    :custom
    (kubel-kubectl "/opt/local/bin/kubectl"))
#+end_src


* Ideas


* Init file generation

Where the magic happen!

#+begin_src text :tangle no
  # Local Variables:
  # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-recompile-file "~/.config/emacs/init.el")) nil t)
  # End:
#+end_src
